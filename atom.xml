<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Seaworth的博客</title>
  <icon>https://www.gravatar.com/avatar/9998bd28245b0d41baf0d705eb72d0d0</icon>
  <subtitle>青山不改，绿水长流</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://seaworth.github.io/"/>
  <updated>2019-10-26T13:40:14.878Z</updated>
  <id>http://seaworth.github.io/</id>
  
  <author>
    <name>Seaworth</name>
    <email>baichuanemail@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>hexo-yilia主题优化</title>
    <link href="http://seaworth.github.io/2019/10/26/hexo-yilia%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96/"/>
    <id>http://seaworth.github.io/2019/10/26/hexo-yilia主题优化/</id>
    <published>2019-10-26T12:51:52.000Z</published>
    <updated>2019-10-26T13:40:14.878Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>为博客添加站点统计，设置网页标签图标ico，修改头像。最近添加了keep，rss社交图标，在网页的右上角加了<code>fork me on github</code>，然后添加了网站公安备案，ICP备案还在折腾。<a id="more"></a></p></blockquote><h1 id="1-添加站点统计"><a href="#1-添加站点统计" class="headerlink" title="1.添加站点统计"></a>1.添加站点统计</h1><ul><li><a href="http://ibruce.info/2015/04/04/busuanzi/" target="_blank" rel="noopener">不蒜子</a><br>打开<strong>themes\yilia\layout_partial\footer.ejs</strong>添加以下脚本即可。<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">async</span> <span class="attr">src</span>=<span class="string">"//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">calss</span>=<span class="string">"count-span"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"busuanzi_container_site_pv"</span>&gt;</span></span><br><span class="line">本站总访问量<span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"busuanzi_value_site_pv"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span>次</span><br><span class="line"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"busuanzi_container_site_uv"</span>&gt;</span></span><br><span class="line">本站总访客数<span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"busuanzi_value_site_uv"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span>人</span><br><span class="line"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"busuanzi_container_page_pv"</span>&gt;</span></span><br><span class="line">本文总阅读量<span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"busuanzi_value_page_pv"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span>次</span><br><span class="line"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><img src="/2019/10/26/hexo-yilia主题优化/1.png" title="This is an example image"><h1 id="2-设置网页标签图标"><a href="#2-设置网页标签图标" class="headerlink" title="2.设置网页标签图标"></a>2.设置网页标签图标</h1><ul><li>去<a href="http://www.bitbug.net/" target="_blank" rel="noopener">比特虫</a>做icon图标</li><li>把favicon.ico图片放到<strong>F:\blog\public\img</strong>文件夹下面</li><li>找到<strong>F:\blog\themes\yilia\layout_partial\head.ejs</strong>，设置为<figure class="highlight erb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">%</span></span></span><span class="ruby"> <span class="keyword">if</span> (theme.favicon)&#123; </span><span class="xml"><span class="tag">%&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"icon"</span> <span class="attr">href</span>=<span class="string">"/img/favicon.ico"</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">%</span></span></span><span class="ruby"> &#125; </span><span class="xml"><span class="tag">%&gt;</span></span></span><br></pre></td></tr></table></figure></li></ul><h1 id="3-修改头像"><a href="#3-修改头像" class="headerlink" title="3.修改头像"></a>3.修改头像</h1><ul><li>将avater.jpg头像保存在<strong>F:\blog\public\img</strong>中</li><li>打开<strong>F:\blog\themes\yilia_config.yml</strong>，设置为<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#你的头像url</span></span><br><span class="line"><span class="symbol">avatar:</span> <span class="string">"/img/avater.jpg"</span></span><br></pre></td></tr></table></figure></li></ul><img src="/2019/10/26/hexo-yilia主题优化/2.png" title="This is an example image"><h1 id="5-添加社交图标"><a href="#5-添加社交图标" class="headerlink" title="5.添加社交图标"></a>5.添加社交图标</h1><p>因为yilia主题左侧的社交图标不包含keep，在网上找到一种比较靠谱的方法添加自己需要的社交图标。<a href="https://blog.csdn.net/qq_40922859/article/details/100878573" target="_blank" rel="noopener">Yilia主题增加左侧社交图标</a>。</p><h1 id="6-添加fork-me-on-github链接"><a href="#6-添加fork-me-on-github链接" class="headerlink" title="6.添加fork me on github链接"></a>6.添加fork me on github链接</h1><p>效果如下：<br><img src="https://s2.ax1x.com/2019/10/26/KDNqaD.png" alt="KDNqaD.png"><br><a href="https://github.blog/2008-12-19-github-ribbons/" target="_blank" rel="noopener">源代码链接</a><br>打开<code>yilia\layout\layout.ejs</code>文件，在下面图片的位置添加相应的代码，如果要修改颜色，可以到<a href="https://github.blog/2008-12-19-github-ribbons/" target="_blank" rel="noopener">这里</a>去拷贝对应颜色的图片。<br><img src="/2019/10/26/hexo-yilia主题优化/p1.png" title="This is an example image"></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;a class=<span class="string">"fork"</span> href=<span class="string">"https://github.com/you"</span>&gt;&lt;img <span class="built_in">width</span>=<span class="string">"149"</span> <span class="built_in">height</span>=<span class="string">"149"</span> src=<span class="string">"https://github.blog/wp-content/uploads/2008/12/forkme_right_gray_6d6d6d.png?resize=149%2C149"</span> class=<span class="string">"attachment-full size-full"</span> alt=<span class="string">"Fork me on GitHub"</span> data-recalc-dims=<span class="string">"1"</span>&gt;&lt;/a&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">.fork&#123;<span class="built_in">display</span>:none;&#125;</span><br><span class="line">.fork&#123;</span><br><span class="line"><span class="built_in">position</span>:fixed;</span><br><span class="line">z-index:<span class="number">999</span>;</span><br><span class="line">top:<span class="number">0</span>;</span><br><span class="line">right:<span class="number">.5</span>em</span><br><span class="line">&#125;</span><br><span class="line">@media(<span class="built_in">min</span>-<span class="built_in">width</span>:<span class="number">768</span>px)&#123;.fork&#123;<span class="built_in">display</span>:<span class="keyword">inline</span>;&#125;&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>注意要将<code>https://github.com/you</code>改为自己的github页面的链接。<br>参考博客：<a href="https://anyway1314.cn/post/e880888a.html" target="_blank" rel="noopener">Yilia主题添加”Fork me on github”</a></p><h1 id="7-添加网站公安备案"><a href="#7-添加网站公安备案" class="headerlink" title="7.添加网站公安备案"></a>7.添加网站公安备案</h1><p>在<a href="http://www.beian.gov.cn/portal/index.do" target="_blank" rel="noopener">全国互联网安全管理服务平台</a>办理，需要拍照身份证这些，大概2-3天解决，通过了就会发一个备案号和备案图案，以及相应的HTML代码，用来显示在网页的底部。<br>先将备案图案置于<code>\blog\themes\yilia\source\img</code>下，通过<code>/img/备案图标.png</code>的方式来索引到。<br>备案代码如下：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">div</span> style=<span class="string">"width:300px;margin:0 auto; padding:20px 0;"</span>&gt;</span><br><span class="line">&lt;<span class="selector-tag">a</span> target=<span class="string">"_blank"</span> href=<span class="string">"http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=50010802003133"</span> style=<span class="string">"display:inline-block;text-decoration:none;height:20px;line-height:20px;"</span>&gt;&lt;<span class="selector-tag">img</span> src=<span class="string">""</span> style=<span class="string">"float:left;"</span>/&gt;&lt;<span class="selector-tag">p</span> style=<span class="string">"float:left;height:20px;line-height:20px;margin: 0px 0px 0px 5px; color:#939393;"</span>&gt;渝公网安备 <span class="number">50010802003133</span>号&lt;/p&gt;&lt;/a&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p>打开<code>\blog\themes\yilia\layout\_partial\footer.ejs</code>文件中，在访问量的代码前添加以下代码。</p><img src="/2019/10/26/hexo-yilia主题优化/p2.png" title="This is an example image"><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">div</span> style=<span class="string">"width:300px;margin:0 auto; padding:2px 0;"</span>&gt;</span><br><span class="line">&lt;<span class="selector-tag">a</span> target=<span class="string">"_blank"</span> href=<span class="string">"http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=50010802003133"</span> style=<span class="string">"display:inline-block;text-decoration:none;height:20px;line-height:20px;"</span>&gt;&lt;<span class="selector-tag">img</span> src=<span class="string">"/img/备案图标.png"</span> style=<span class="string">"float:left;"</span>/&gt;&lt;<span class="selector-tag">p</span> style=<span class="string">"float:left;height:20px;line-height:20px;margin: 0px 0px 0px 5px; color:#939393;"</span>&gt;渝公网安备 <span class="number">50010802003133</span>号&lt;/p&gt;&lt;/a&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>注意要将<code>padding:20px</code>改为<code>padding:2px</code>，这样间距看起来比较合适。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;为博客添加站点统计，设置网页标签图标ico，修改头像。最近添加了keep，rss社交图标，在网页的右上角加了&lt;code&gt;fork me on github&lt;/code&gt;，然后添加了网站公安备案，ICP备案还在折腾。
    
    </summary>
    
    
    
      <category term="hexo" scheme="http://seaworth.github.io/tags/hexo/"/>
    
      <category term="yilia" scheme="http://seaworth.github.io/tags/yilia/"/>
    
  </entry>
  
  <entry>
    <title>自己实现ls -l dir命令</title>
    <link href="http://seaworth.github.io/2019/10/20/%E8%87%AA%E5%B7%B1%E5%AE%9E%E7%8E%B0ls-l-dir%E5%91%BD%E4%BB%A4/"/>
    <id>http://seaworth.github.io/2019/10/20/自己实现ls-l-dir命令/</id>
    <published>2019-10-20T03:25:50.000Z</published>
    <updated>2019-10-20T08:31:45.580Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>时间永远是最短缺的，没有任何东西可以替代已失去的时间。有效的管理者与他人最大的区别，就是他们非常珍惜自己的时间。但是往往人最不擅长管理自己的时间。</p><footer><strong>【美】彼得·德鲁克</strong><cite>《卓有成效的管理者》</cite></footer></blockquote><a id="more"></a><blockquote><p>本次要实现的功能是ls -l dir，就是罗列出dir文件夹下的所有文件的详细信息，要实现这个功能需要学习stat、opendir、readdir、closedir函数。stat函数主要用来获取每个文件或文件夹的相关属性，dir相关的三个函数主要用来获取文件夹下的所有文件，然后再对每个文件获取相关的属性，实现的功能如下图所示。</p></blockquote><img src="/2019/10/20/自己实现ls-l-dir命令/Snipaste_2019-10-20_15-01-35.png" title="This is an image"><h1 id="1-相关函数"><a href="#1-相关函数" class="headerlink" title="1.相关函数"></a>1.相关函数</h1><h2 id="1-1-stat函数"><a href="#1-1-stat函数" class="headerlink" title="1.1 stat函数"></a>1.1 stat函数</h2><p>在Linux终端查看stat函数的说明，使用<code>man 2 stat</code>。stat函数需要包含的头文件和函数声明如下。<br><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> stat(<span class="keyword">const</span> char *pathname, struct stat *buf)<span class="comment">;</span></span><br></pre></td></tr></table></figure></p><p>功能：调用stat，得到文件相关的属性<br>描述：<br>pathname，文件或路径的名称<br>buf，stat结构体的指针<br><figure class="highlight cpp"><figcaption><span>a stat structure</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> &#123;</span></span><br><span class="line">   <span class="keyword">dev_t</span>     st_dev;         <span class="comment">/* ID of device containing file */</span></span><br><span class="line">   <span class="keyword">ino_t</span>     st_ino;         <span class="comment">/* inode number */</span></span><br><span class="line">   <span class="keyword">mode_t</span>    st_mode;        <span class="comment">/* protection */</span></span><br><span class="line">   <span class="keyword">nlink_t</span>   st_nlink;       <span class="comment">/* number of hard links */</span></span><br><span class="line">   <span class="keyword">uid_t</span>     st_uid;         <span class="comment">/* user ID of owner */</span></span><br><span class="line">   <span class="keyword">gid_t</span>     st_gid;         <span class="comment">/* group ID of owner */</span></span><br><span class="line">   <span class="keyword">dev_t</span>     st_rdev;        <span class="comment">/* device ID (if special file) */</span></span><br><span class="line">   <span class="keyword">off_t</span>     st_size;        <span class="comment">/* total size, in bytes */</span></span><br><span class="line">   <span class="keyword">blksize_t</span> st_blksize;     <span class="comment">/* blocksize for filesystem I/O */</span></span><br><span class="line">   <span class="keyword">blkcnt_t</span>  st_blocks;      <span class="comment">/* number of 512B blocks allocated */</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* Since Linux 2.6, the kernel supports nanosecond</span></span><br><span class="line"><span class="comment">  precision for the following timestamp fields.</span></span><br><span class="line"><span class="comment">  For the details before Linux 2.6, see NOTES. */</span></span><br><span class="line"></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">st_atim</span>;</span>  <span class="comment">/* time of last access */</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">st_mtim</span>;</span>  <span class="comment">/* time of last modification */</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">st_ctim</span>;</span>  <span class="comment">/* time of last status change */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> st_atime st_atim.tv_sec      <span class="comment">/* Backward compatibility */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> st_mtime st_mtim.tv_sec</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> st_ctime st_ctim.tv_sec</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="1-2-opendir函数"><a href="#1-2-opendir函数" class="headerlink" title="1.2 opendir函数"></a>1.2 opendir函数</h2><p>在Linux终端查看opendir函数的说明，使用<code>man opendir</code>。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dirent.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">DIR *<span class="title">opendir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</span><br></pre></td></tr></table></figure></p><p>功能：打开一个文件夹。<br>描述：<br>name，文件的名字<br>返回值是一个指向文件流的指针。</p><h2 id="1-3-readdir函数"><a href="#1-3-readdir函数" class="headerlink" title="1.3 readdir函数"></a>1.3 readdir函数</h2><p>在Linux终端查看readdir函数的说明，使用<code>man readdir</code>。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dirent.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">struct dirent *<span class="title">readdir</span><span class="params">(DIR *dirp)</span></span>;</span><br></pre></td></tr></table></figure></p><p>功能：读文件夹<br>描述：<br>dirp，一个指向文件流的指针，和opendir函数的返回值是同一个类型。<br>dirent，dirent结构体的指针<br><figure class="highlight cpp"><figcaption><span>dirent structure</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> &#123;</span></span><br><span class="line">   <span class="keyword">ino_t</span>          d_ino;       <span class="comment">/* inode number */</span></span><br><span class="line">   <span class="keyword">off_t</span>          d_off;       <span class="comment">/* not an offset; see NOTES */</span></span><br><span class="line">   <span class="keyword">unsigned</span> <span class="keyword">short</span> d_reclen;    <span class="comment">/* length of this record */</span></span><br><span class="line">   <span class="keyword">unsigned</span> <span class="keyword">char</span>  d_type;      <span class="comment">/* type of file; not supported</span></span><br><span class="line"><span class="comment">  by all filesystem types */</span></span><br><span class="line">   <span class="keyword">char</span>           d_name[<span class="number">256</span>]; <span class="comment">/* filename */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="1-4-closedir函数"><a href="#1-4-closedir函数" class="headerlink" title="1.4 closedir函数"></a>1.4 closedir函数</h2><p>在Linux终端查看closedir函数的说明，使用<code>man closedir</code>。<br><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dirent.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> closedir(DIR *dirp)<span class="comment">;</span></span><br></pre></td></tr></table></figure></p><p>功能：关闭文件夹。<br>描述：<br>dirp，文件流的指针。</p><h1 id="2-功能实现"><a href="#2-功能实现" class="headerlink" title="2.功能实现"></a>2.功能实现</h1><p>要实现ls -l dir的功能，就要实现两个函数，一个是DirCount函数，遍历当前目录下的所有文件。第二是GetFileInfo函数，利用stat函数，取得传入该函数的文件的属性，并连接成字符串，打印出来。</p><figure class="highlight cpp"><figcaption><span>13_homework.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;grp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pwd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dirent.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetFileInfo</span><span class="params">(<span class="keyword">char</span>* filename)</span></span>;</span><br><span class="line"><span class="comment">//目录计数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DirCount</span><span class="params">(<span class="keyword">char</span> *dirname)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//printf("%s\n", dirname);</span></span><br><span class="line"><span class="comment">//打开目录</span></span><br><span class="line">DIR *dirp = opendir(dirname);</span><br><span class="line"><span class="keyword">if</span>(dirp == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">"opendir err"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//循环读目录，如果是普通文件，count++，如果是目录，继续调用DirCount</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *<span class="title">dentp</span> = <span class="title">NULL</span>;</span></span><br><span class="line"><span class="keyword">while</span>( (dentp = readdir(dirp)) !=<span class="literal">NULL</span> ) </span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">strcmp</span>(<span class="string">"."</span>, dentp-&gt;d_name)==<span class="number">0</span> || <span class="built_in">strcmp</span>(<span class="string">".."</span>, dentp-&gt;d_name)==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">continue</span>;<span class="comment">//如果是当前目录和上一级目录，跳过</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GetFileInfo(dentp-&gt;d_name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//关闭目录</span></span><br><span class="line">closedir(dirp);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetFileInfo</span><span class="params">(<span class="keyword">char</span>* filename)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//调用stat，得到文件属性信息</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">sb</span>;</span></span><br><span class="line">stat(filename,&amp;sb);</span><br><span class="line"><span class="keyword">char</span> stmode[<span class="number">11</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(stmode,<span class="string">'-'</span>,<span class="keyword">sizeof</span>(stmode)<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(S_ISREG(sb.st_mode)) stmode[<span class="number">0</span>]=<span class="string">'-'</span>;</span><br><span class="line"><span class="keyword">if</span>(S_ISDIR(sb.st_mode)) stmode[<span class="number">0</span>]=<span class="string">'d'</span>;</span><br><span class="line"><span class="keyword">if</span>(S_ISCHR(sb.st_mode)) stmode[<span class="number">0</span>]=<span class="string">'c'</span>;</span><br><span class="line"><span class="keyword">if</span>(S_ISBLK(sb.st_mode)) stmode[<span class="number">0</span>]=<span class="string">'b'</span>;</span><br><span class="line"><span class="keyword">if</span>(S_ISFIFO(sb.st_mode)) stmode[<span class="number">0</span>]=<span class="string">'p'</span>;</span><br><span class="line"><span class="keyword">if</span>(S_ISLNK(sb.st_mode)) stmode[<span class="number">0</span>]=<span class="string">'l'</span>;</span><br><span class="line"><span class="keyword">if</span>(S_ISSOCK(sb.st_mode)) stmode[<span class="number">0</span>]=<span class="string">'s'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//解析权限</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(sb.st_mode &amp; S_IRUSR)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,S_IRUSR);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,sb.st_mode);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,(sb.st_mode&amp;S_IRUSR));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%x\n"</span>,<span class="number">0b101</span>&amp;<span class="number">0b101</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">stmode[<span class="number">1</span>]=<span class="string">'r'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(sb.st_mode &amp; S_IWUSR) stmode[<span class="number">2</span>]=<span class="string">'w'</span>;</span><br><span class="line"><span class="keyword">if</span>(sb.st_mode &amp; S_IXUSR) stmode[<span class="number">3</span>]=<span class="string">'x'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(sb.st_mode &amp; S_IRGRP) stmode[<span class="number">4</span>]=<span class="string">'r'</span>;</span><br><span class="line"><span class="keyword">if</span>(sb.st_mode &amp; S_IWGRP) stmode[<span class="number">5</span>]=<span class="string">'w'</span>;</span><br><span class="line"><span class="keyword">if</span>(sb.st_mode &amp; S_IXGRP) stmode[<span class="number">6</span>]=<span class="string">'x'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(sb.st_mode &amp; S_IROTH) stmode[<span class="number">7</span>]=<span class="string">'r'</span>;</span><br><span class="line"><span class="keyword">if</span>(sb.st_mode &amp; S_IWOTH) stmode[<span class="number">8</span>]=<span class="string">'w'</span>;</span><br><span class="line"><span class="keyword">if</span>(sb.st_mode &amp; S_IXOTH) stmode[<span class="number">9</span>]=<span class="string">'x'</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//测试memset的用法</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line"><span class="keyword">char</span> str[] = <span class="string">"almost every programmer should know memset!"</span>;</span><br><span class="line"><span class="built_in">puts</span> (str);</span><br><span class="line"><span class="built_in">memset</span> (str,<span class="string">'-'</span>,<span class="number">6</span>);</span><br><span class="line"><span class="built_in">puts</span> (str);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tm</span> *<span class="title">filetm</span> = <span class="title">localtime</span>(&amp;<span class="title">sb</span>.<span class="title">st_atim</span>.<span class="title">tv_sec</span>);</span></span><br><span class="line"><span class="keyword">char</span>* str;</span><br><span class="line">str=ctime(&amp;sb.st_mtime);</span><br><span class="line"><span class="keyword">char</span> timebuf[<span class="number">13</span>] =&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="built_in">strncpy</span>(timebuf,str+<span class="number">4</span>,<span class="number">12</span>);</span><br><span class="line">timebuf[<span class="number">13</span>] = <span class="string">'\0'</span>;<span class="comment">//要添加结束符，不然打印会出现乱码</span></span><br><span class="line"><span class="comment">//puts(timebuf);</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s %ld %s %s %6ld %12s %s\n"</span>,stmode,sb.st_nlink,getpwuid(sb.st_uid)-&gt;pw_name,getgrgid(sb.st_gid)-&gt;gr_name,sb.st_size,timebuf,filename);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>*argv [])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(argc !=<span class="number">2</span> )</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"./13_homework filename\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">DirCount(argv[<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相关的Makefile文件。<br><figure class="highlight makefile"><figcaption><span>makefile</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">srcFiles := <span class="variable">$(<span class="built_in">wildcard</span> *.c)</span></span><br><span class="line">objects := <span class="variable">$(<span class="built_in">patsubst</span> %.c,%,<span class="variable">$(srcFiles)</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="section">all:<span class="variable">$(objects)</span></span></span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>:all</span></span><br><span class="line"></span><br><span class="line"><span class="section">%:%.c</span></span><br><span class="line">gcc <span class="variable">$^</span> -o <span class="variable">$@</span> -g</span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>:clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">-rm -f <span class="variable">$(objects)</span></span><br></pre></td></tr></table></figure><br>然后再终端执行<code>make</code>，生成执行文件。<br><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">seaworth@ubuntu:~/Desktop/file_dir$ make</span><br><span class="line">gcc 13_homework.c -o 13_homework -g</span><br><span class="line">seaworth@ubuntu:~/Desktop/file_dir$ ./13_homework ./</span><br><span class="line">-rw-rw-r--<span class="number"> 2 </span>seaworth seaworth   <span class="number"> 370 </span>Oct<span class="number"> 12 </span>10:46 hello.txt</span><br><span class="line">-rwxrwxr-x<span class="number"> 1 </span>seaworth seaworth <span class="number"> 11304 </span>Oct<span class="number"> 20 </span>16:28 02_ls</span><br><span class="line">-rw-rw-r--<span class="number"> 1 </span>seaworth seaworth  <span class="number"> 1861 </span>Oct<span class="number"> 15 </span>19:10 02_ls.c</span><br><span class="line">-rwxrwxr-x<span class="number"> 1 </span>seaworth seaworth <span class="number"> 10112 </span>Oct<span class="number"> 20 </span>16:28 01_openmax</span><br><span class="line">-rw-rw-r--<span class="number"> 1 </span>seaworth seaworth   <span class="number"> 246 </span>Oct<span class="number"> 12 </span>11:05 06_readlink_unlink.c</span><br><span class="line">-rw-rw-r--<span class="number"> 1 </span>seaworth seaworth   <span class="number"> 137 </span>Oct<span class="number"> 12 </span>15:38 10_mkdir.c</span><br><span class="line">-rwxrwxr-x<span class="number"> 1 </span>seaworth seaworth  <span class="number"> 9752 </span>Oct<span class="number"> 20 </span>16:28 10_mkdir</span><br><span class="line">-rw-rw-r--<span class="number"> 1 </span>seaworth seaworth   <span class="number"> 237 </span>Sep<span class="number"> 29 </span>17:04 stat.c</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;时间永远是最短缺的，没有任何东西可以替代已失去的时间。有效的管理者与他人最大的区别，就是他们非常珍惜自己的时间。但是往往人最不擅长管理自己的时间。&lt;/p&gt;
&lt;footer&gt;&lt;strong&gt;【美】彼得·德鲁克&lt;/strong&gt;&lt;cite&gt;《卓有成效的管理者》&lt;/cite&gt;&lt;/footer&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
    
      <category term="Linux" scheme="http://seaworth.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>IT资源 持续更新</title>
    <link href="http://seaworth.github.io/2019/10/16/IT%E8%B5%84%E6%BA%90/"/>
    <id>http://seaworth.github.io/2019/10/16/IT资源/</id>
    <published>2019-10-16T06:46:03.000Z</published>
    <updated>2019-10-16T11:58:08.912Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>开源共享，好的资源分享才能更大化地发挥它的价值！<a id="more"></a><br>在学习的过程中，收藏了一些有用资源（下载论文、绿化软件、windows系统等），推荐给大家~</p></blockquote><h1 id="1-论文书籍下载"><a href="#1-论文书籍下载" class="headerlink" title="1 论文书籍下载"></a>1 论文书籍下载</h1><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">简介</th></tr></thead><tbody><tr><td style="text-align:center"><a href="http://gen.lib.rus.ec/" target="_blank" rel="noopener">Library Genesis</a></td><td style="text-align:center"><strong>科研党的神器！</strong>下载专著书籍相当给力。</td></tr><tr><td style="text-align:center"><a href="https://sci-hub.tw/" target="_blank" rel="noopener">SCI-HUB</a></td><td style="text-align:center">可下载大量的学术论文</td></tr><tr><td style="text-align:center"><a href="http://www.6453.net/" target="_blank" rel="noopener">Google学术搜索</a></td><td style="text-align:center">龙猫学术导航，包含SCI-HUB和Google学术等网站链接</td></tr><tr><td style="text-align:center"><a href="http://www.sci-hub.ac.cn/" target="_blank" rel="noopener">文献小镇</a></td><td style="text-align:center">学术导航，包含SCI-HUB和Google学术等网站链接</td></tr><tr><td style="text-align:center"><a href="http://www.4243.net/" target="_blank" rel="noopener">大木虫学术导航</a></td><td style="text-align:center">包含Google镜像，Sci-hub和谷歌学术等</td></tr></tbody></table><h1 id="2-软件工具"><a href="#2-软件工具" class="headerlink" title="2 软件工具"></a>2 软件工具</h1><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">简介</th></tr></thead><tbody><tr><td style="text-align:center"><a href="https://mathpix.com/" target="_blank" rel="noopener">Mathpix Snip</a></td><td style="text-align:center">识别公式的神器，在撰写论文时，会参考其他论文的公式，直接用Mathpix识别，粘贴在mathtype中，就可以了，相当节约时间。</td></tr><tr><td style="text-align:center"><a href="https://msdn.itellyou.cn/" target="_blank" rel="noopener">MSDN,我告诉你</a></td><td style="text-align:center">Windows系统，Office等办公软件下载，<strong>本站资源均来自于官方原版</strong>，没有其他的捆绑软件，很干净。<strong>安装系统推荐这个网站！</strong></td></tr></tbody></table><h1 id="3-软件下载"><a href="#3-软件下载" class="headerlink" title="3 软件下载"></a>3 软件下载</h1><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">简介</th></tr></thead><tbody><tr><td style="text-align:center"><a href="https://www.xitmi.com/" target="_blank" rel="noopener">系统迷</a></td><td style="text-align:center">分享精品资源，包含系统、绿色软件等</td></tr><tr><td style="text-align:center"><a href="https://www.ghpym.com/" target="_blank" rel="noopener">果壳剥壳</a></td><td style="text-align:center">果壳里含有大量的纯净绿软，PC端，安卓端，补丁，系统，教程等。资源党酷爱的一个网站:)</td></tr></tbody></table><blockquote><p>你的分享，让世界大不一样！欢迎留言，分享你star过的网站~</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;开源共享，好的资源分享才能更大化地发挥它的价值！
    
    </summary>
    
    
    
      <category term="IT资源" scheme="http://seaworth.github.io/tags/IT%E8%B5%84%E6%BA%90/"/>
    
  </entry>
  
  <entry>
    <title>Linux中的文件IO操作</title>
    <link href="http://seaworth.github.io/2019/09/24/Linux%E4%B8%AD%E7%9A%84%E6%96%87%E4%BB%B6IO%E6%93%8D%E4%BD%9C/"/>
    <id>http://seaworth.github.io/2019/09/24/Linux中的文件IO操作/</id>
    <published>2019-09-24T13:27:50.000Z</published>
    <updated>2019-09-26T13:25:23.545Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>回顾我自己已走过的历史，扪心自问，我一生无愧于祖国、无愧于人民，无愧于事业与员工，无愧于朋友，唯一有愧的是对不起父母，没条件时没有照顾他们，有条件时也没有照顾他们。——任正非《我的父亲母亲》<a id="more"></a></p></blockquote><h1 id="1-文件概述"><a href="#1-文件概述" class="headerlink" title="1.文件概述"></a>1.文件概述</h1><p>Linux中，一切皆文件。文件为操作系统服务和设备提供了一个简单而一致的接口。<br>文件IO主要包含5个函数，如下所示：</p><ul><li>open，打开或创建一个文件</li><li>close，关闭一个文件描述符</li><li>read，从打开的文件或设备里读数据</li><li>write，向文件或设备写数据</li><li>lseek，重新定位读/写文件偏移量</li></ul><h2 id="open"><a href="#open" class="headerlink" title="open"></a>open</h2><p>在终端查看open函数的用法：<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">seaworth<span class="variable">@ubuntu</span><span class="symbol">:~/Desktop/io</span><span class="variable">$ </span>man <span class="number">2</span> open</span><br></pre></td></tr></table></figure></p><p>调用open函数，需要包含的头文件如下：<br><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br></pre></td></tr></table></figure></p><p>函数的形式：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> flags, <span class="keyword">mode_t</span> mode)</span></span>;</span><br></pre></td></tr></table></figure></p><p>函数参数：</p><ul><li>pathname，文件名</li><li>flags，访问模式的参数标志<ul><li>必选项：<code>O_RDONLY</code>, <code>O_WRONLY</code>, <code>O_RDWR</code></li><li>可选项：<code>O_APPEND</code>, <code>O_CREAT</code>, <code>O_NONBLOCK</code>（<code>O_APPEND</code>以追加的方式打开，<code>O_CREAT</code>创建文件，<code>O_CREAT</code>与<code>O_EXCL</code>一起使用，如果文件存在，则报错。）</li></ul></li><li>mode，权限位，以<code>mode&amp;~umask</code>的方式生成，<code>umask</code>的值为<code>0002</code>。</li></ul><p>返回值：<br>返回最小的可用文件描述符，失败返回-1，并且设置错误数字errno。</p><h2 id="close"><a href="#close" class="headerlink" title="close"></a>close</h2><p>在终端查看close函数的用法：<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">seaworth<span class="variable">@ubuntu</span><span class="symbol">:~/Desktop/io</span><span class="variable">$ </span>man close</span><br></pre></td></tr></table></figure></p><p>功能：关闭打开的文件描述符。<br>调用close函数，需要包含的头文件如下：<br><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br></pre></td></tr></table></figure></p><p>函数的形式：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br></pre></td></tr></table></figure></p><p>函数参数：</p><ul><li>fd，打开的文件描述符</li></ul><p>返回值：调用成功返回0，失败返回-1，并设置错误数字errono</p><h2 id="read"><a href="#read" class="headerlink" title="read"></a>read</h2><p>在终端查看read函数的用法：<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">seaworth<span class="variable">@ubuntu</span><span class="symbol">:~/Desktop/io</span><span class="variable">$ </span>man read</span><br></pre></td></tr></table></figure></p><p>调用close函数，需要包含的头文件如下：<br><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br></pre></td></tr></table></figure></p><p>函数的形式：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ssize_t</span> read(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count);</span><br></pre></td></tr></table></figure></p><p>函数参数：</p><ul><li>fd，打开的文件描述符</li><li>buf，缓冲区</li><li>count，写入count个字节到缓冲区</li></ul><p>返回值：</p><ul><li>成功，返回读到的大小</li><li>失败，返回-1</li><li>0表示读到文件末尾</li></ul><h2 id="write"><a href="#write" class="headerlink" title="write"></a>write</h2><p>在终端查看write函数的用法：<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">seaworth<span class="variable">@ubuntu</span><span class="symbol">:~/Desktop/io</span><span class="variable">$ </span>man <span class="number">2</span> write</span><br></pre></td></tr></table></figure></p><p>调用write函数，需要包含的头文件如下：<br><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br></pre></td></tr></table></figure></p><p>函数的形式：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ssize_t</span> write(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count);</span><br></pre></td></tr></table></figure></p><p>函数参数：</p><ul><li>fd，打开的文件描述符</li><li>buf，缓冲区</li><li>count，从缓冲区写入count个字节到fd文件中</li></ul><p>返回值：</p><ul><li>成功，返回写了多少字节</li><li>失败，返回-1</li><li>0表示什么也没有写</li></ul><h2 id="lseek"><a href="#lseek" class="headerlink" title="lseek"></a>lseek</h2><p>在终端查看lseek函数的用法：<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">seaworth<span class="variable">@ubuntu</span><span class="symbol">:~/Desktop/io</span><span class="variable">$ </span>man <span class="number">2</span> lseek</span><br></pre></td></tr></table></figure></p><p>调用lseek函数，需要包含的头文件如下：<br><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br></pre></td></tr></table></figure></p><p>函数的形式：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">off_t</span> lseek(<span class="keyword">int</span> fd, <span class="keyword">off_t</span> offset, <span class="keyword">int</span> whence);</span><br></pre></td></tr></table></figure></p><p>函数参数：</p><ul><li>fd，打开的文件描述符</li><li>offset，偏移量</li><li>whence<ul><li>SEEK_SET文件开始位置</li><li>SEEK_CUR文件当前位置</li><li>SEEK_END文件结尾</li></ul></li></ul><p>返回值：</p><ul><li>成功，返回当前位置到开始的长度</li><li>失败，返回-1，并设置errno</li></ul><h1 id="2-三个小实践"><a href="#2-三个小实践" class="headerlink" title="2.三个小实践"></a>2.三个小实践</h1><h2 id="实现touch指令"><a href="#实现touch指令" class="headerlink" title="实现touch指令"></a>实现touch指令</h2><p>创建<code>mytouch.c</code>文件<br><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> main(<span class="built_in">int</span> argc, char* argv[])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(argc!=<span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">printf(<span class="string">"./mytouch filename\n"</span>)<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">int</span> fd = open(argv[<span class="number">1</span>],O_RDONLY|O_CREAT,<span class="number">0666</span>)<span class="comment">;</span></span><br><span class="line">close(fd)<span class="comment">;</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span><span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>编译生成可执行文件<code>mytouch</code><br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">seaworth<span class="variable">@ubuntu</span><span class="symbol">:~/Desktop/io</span><span class="variable">$ </span>gcc mytouch.c -o mytouch</span><br><span class="line">seaworth<span class="variable">@ubuntu</span><span class="symbol">:~/Desktop/io</span><span class="variable">$ </span>./mytouch <span class="number">1</span>.log</span><br><span class="line">seaworth<span class="variable">@ubuntu</span><span class="symbol">:~/Desktop/io</span><span class="variable">$ </span>ls -lrt</span><br><span class="line">-rw-rw-r-- <span class="number">1</span> seaworth seaworth  <span class="number">264</span> Sep <span class="number">18</span> <span class="number">20</span><span class="symbol">:</span><span class="number">24</span> mytouch.c</span><br><span class="line">-rw-rw-r-- <span class="number">1</span> seaworth seaworth    <span class="number">0</span> Sep <span class="number">26</span> <span class="number">20</span><span class="symbol">:</span><span class="number">59</span> <span class="number">1</span>.log</span><br><span class="line">-rwxrwxr-x <span class="number">1</span> seaworth seaworth <span class="number">8704</span> Sep <span class="number">26</span> <span class="number">21</span><span class="symbol">:</span><span class="number">06</span> mytouch</span><br></pre></td></tr></table></figure></p><h2 id="实现cat功能"><a href="#实现cat功能" class="headerlink" title="实现cat功能"></a>实现cat功能</h2><p>编写<code>mycat.c</code>文件，实现读取文件内容并且输出到屏幕上。<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">if</span>(argc!=<span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">printf(<span class="string">"./mycat filename\n"</span>);</span><br><span class="line"><span class="built_in">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> fd = <span class="built_in">open</span>(argv[<span class="number">1</span>],O_RDONLY);</span><br><span class="line"><span class="comment">//读，输出到屏幕</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">256</span>];</span><br><span class="line"><span class="keyword">int</span> ret = <span class="built_in">read</span>(fd,buf,<span class="keyword">sizeof</span>(buf));</span><br><span class="line"><span class="built_in">while</span>(ret)<span class="comment">//循环输出，直到文件末尾</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">write</span>(STDOUT_FILENO,buf,ret); </span><br><span class="line">ret = <span class="built_in">read</span>(fd,buf,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">close</span>(fd);</span><br><span class="line"><span class="built_in">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>生成可执行文件<code>mycat</code><br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">seaworth<span class="variable">@ubuntu</span><span class="symbol">:~/Desktop/io</span><span class="variable">$ </span>gcc mycat.c -o mycat</span><br><span class="line">seaworth<span class="variable">@ubuntu</span><span class="symbol">:~/Desktop/io</span><span class="variable">$ </span>./mycat filename</span><br></pre></td></tr></table></figure></p><h2 id="打开一个文件，写入helloworld，并读取文件内容显示"><a href="#打开一个文件，写入helloworld，并读取文件内容显示" class="headerlink" title="打开一个文件，写入helloworld，并读取文件内容显示"></a>打开一个文件，写入helloworld，并读取文件内容显示</h2><p>创建<code>myreadwrite.c</code>文件<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">if</span>(argc!=<span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">printf(<span class="string">"./myreadwirte filename\n"</span>);</span><br><span class="line"><span class="built_in">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建文件并写入hello world</span></span><br><span class="line"><span class="comment">//读取文件中的内容，并显示</span></span><br><span class="line"><span class="keyword">int</span> fd = <span class="built_in">open</span>(argv[<span class="number">1</span>],O_RDWR|O_CREAT,<span class="number">0666</span>);</span><br><span class="line"><span class="keyword">char</span> input[]=<span class="string">"hello world"</span>;</span><br><span class="line"><span class="built_in">write</span>(fd,input,<span class="keyword">sizeof</span>(input));</span><br><span class="line"><span class="comment">//这时候文件指针在文件的末尾，需要重新指定文件指针的位置到文件首</span></span><br><span class="line">lseek(fd, <span class="number">0</span>, SEEK_SET);</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">256</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="built_in">read</span>(fd,buf,<span class="keyword">sizeof</span>(buf));</span><br><span class="line"><span class="built_in">while</span>(ret)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">write</span>(STDOUT_FILENO,buf,ret); <span class="comment">//STDIN_FILENO,STDERR_FILENO</span></span><br><span class="line">ret = <span class="built_in">read</span>(fd,buf,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">close</span>(fd);</span><br><span class="line"><span class="built_in">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>编译程序，生成可执行文件<code>myreadwirte</code><br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">seaworth<span class="variable">@ubuntu</span><span class="symbol">:~/Desktop/io</span><span class="variable">$ </span>gcc myreadwrite.c -o myreadwrite</span><br><span class="line">seaworth<span class="variable">@ubuntu</span><span class="symbol">:~/Desktop/io</span><span class="variable">$ </span>./myreadwrite hello</span><br><span class="line">hello worldseaworth<span class="variable">@ubuntu</span><span class="symbol">:~/Desktop/io</span>$</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;回顾我自己已走过的历史，扪心自问，我一生无愧于祖国、无愧于人民，无愧于事业与员工，无愧于朋友，唯一有愧的是对不起父母，没条件时没有照顾他们，有条件时也没有照顾他们。——任正非《我的父亲母亲》
    
    </summary>
    
    
    
      <category term="Linux" scheme="http://seaworth.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer-3 字符串中子序列的替换</title>
    <link href="http://seaworth.github.io/2019/09/10/%E5%89%91%E6%8C%87Offer-3/"/>
    <id>http://seaworth.github.io/2019/09/10/剑指Offer-3/</id>
    <published>2019-09-10T02:21:18.000Z</published>
    <updated>2019-09-10T02:42:38.016Z</updated>
    
    <content type="html"><![CDATA[<p>题目：查找字符串s中的子序列oldVal，并将oldVal替换为新的子序列newVal。<a id="more"></a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><blockquote><p>编写一个函数，接受三个string参数s、oldVal、newVal。使用迭代器及insert和erase函数将s中所有oldVal替换为newVal。</p></blockquote><h1 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述"></a>输出描述</h1><blockquote><p>s=”To drive straight thru is a foolish, tho courageous act.”<br>oldVal=”thru”<br>newVal=”through”<br>oldVal=”tho”<br>newVal=”though”<br>替换后<br>To drive straight through is a foolish, though courageous act.</p></blockquote><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>首先对字符串s进行遍历，判断是否与oldVal子串相同，如果相同则删除s中的oldVal，并在这个位置添加新的子串newVal，此时的迭代器增加newVal的大小，如果不相同，则遍历下一个，直到遍历到字符串s的长度减去oldVal子串的长度的位置，停止遍历。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> replace_with(<span class="keyword">string</span>&amp; s, <span class="keyword">string</span> <span class="keyword">const</span>&amp; oldVal, <span class="keyword">string</span> <span class="keyword">const</span>&amp; newVal)<span class="comment">//注意参数s一定要是引用，不然无法改变s的值</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">auto</span> cur = s.<span class="built_in">begin</span>();</span><br><span class="line"><span class="built_in">while</span> (cur &lt;= ( s.<span class="built_in">end</span>() - oldVal.<span class="built_in">size</span>() ) )</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">string</span> cmpVal(cur, cur + oldVal.<span class="built_in">size</span>());</span><br><span class="line"><span class="built_in">if</span> (oldVal == cmpVal)</span><br><span class="line">&#123;</span><br><span class="line">cur = s.erase(cur, cur + oldVal.<span class="built_in">size</span>());<span class="comment">//删除旧子串</span></span><br><span class="line">cur = s.insert(cur, newVal.<span class="built_in">begin</span>(), newVal.<span class="built_in">end</span>());<span class="comment">//添加新子串</span></span><br><span class="line">cur += newVal.<span class="built_in">size</span>();<span class="comment">//增加的步长为新子串的长度</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">else</span></span><br><span class="line">&#123;</span><br><span class="line">++cur;<span class="comment">//遍历下一个位置</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目：查找字符串s中的子序列oldVal，并将oldVal替换为新的子序列newVal。
    
    </summary>
    
    
    
      <category term="C++" scheme="http://seaworth.github.io/tags/C/"/>
    
      <category term="剑指" scheme="http://seaworth.github.io/tags/%E5%89%91%E6%8C%87/"/>
    
  </entry>
  
  <entry>
    <title>MATLAB绘制模糊规则图形</title>
    <link href="http://seaworth.github.io/2019/08/28/MATLAB%E7%BB%98%E5%88%B6%E6%A8%A1%E7%B3%8A%E8%A7%84%E5%88%99%E5%9B%BE%E5%BD%A2/"/>
    <id>http://seaworth.github.io/2019/08/28/MATLAB绘制模糊规则图形/</id>
    <published>2019-08-28T13:25:48.000Z</published>
    <updated>2019-08-28T13:38:52.075Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>根植于内心的修养；无需提醒的自觉；以约束为前提的自由；为别人着想的善良。——十点读书<a id="more"></a></p></blockquote><p>今天在写论文的时候，需要将模糊控制中的模糊规则和模糊曲面绘制出来。在网上查找了官方文档，将其总结下来。<br>在MATLAB中，已经设计好的模糊推理系统文件为<code>fuzzy_PID.fis</code>。<br>Display fuzzy inference system的代码如下：<br><figure class="highlight erlang-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">clc</span><br><span class="line">clear</span><br><span class="line">close all</span><br><span class="line"></span><br><span class="line"><span class="comment">% 读取模糊规则</span></span><br><span class="line">fis = readfis(<span class="string">'fuzzy_PID.fis'</span>);</span><br><span class="line">figure</span><br><span class="line">plotfis(fis)<span class="comment">%figure1绘制模糊的结构框图</span></span><br><span class="line">figure</span><br><span class="line">plotmf(fis,<span class="string">'input'</span>,<span class="number">1</span>)<span class="comment">%figure2输入1的规则</span></span><br><span class="line">figure</span><br><span class="line">plotmf(fis,<span class="string">'input'</span>,<span class="number">1</span>)<span class="comment">%figure3输入2的规则</span></span><br><span class="line">figure</span><br><span class="line">plotmf(fis,<span class="string">'output'</span>,<span class="number">1</span>)<span class="comment">%figure4输出1的规则</span></span><br><span class="line">figure</span><br><span class="line">gensurf(fis)<span class="comment">%figure5模糊曲面</span></span><br></pre></td></tr></table></figure></p><p>输出结果为：<br><img src="f1.png" width="50%" height="50%" alt="figure1绘制模糊的结构框图"></p><p><img src="f2.png" width="50%" height="50%" alt="figure2输入1的规则"></p><p><img src="f3.png" width="50%" height="50%" alt="figure3输入2的规则"></p><p><img src="f4.png" width="50%" height="50%" alt="figure4输出1的规则"></p><p><img src="f5.png" width="50%" height="50%" alt="figure5模糊曲面"></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;根植于内心的修养；无需提醒的自觉；以约束为前提的自由；为别人着想的善良。——十点读书
    
    </summary>
    
    
    
      <category term="MATLAB" scheme="http://seaworth.github.io/tags/MATLAB/"/>
    
  </entry>
  
  <entry>
    <title>Effective C++ 笔记</title>
    <link href="http://seaworth.github.io/2019/07/16/effectiveCPP/"/>
    <id>http://seaworth.github.io/2019/07/16/effectiveCPP/</id>
    <published>2019-07-16T01:10:08.000Z</published>
    <updated>2019-08-27T11:30:05.567Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>你的时间有限，所以不要浪费时间去重复别人的生活。<br>Your time is limited, so don’t waste it living someone else’s life.<br>——斯蒂夫.乔布斯<a id="more"></a></p></blockquote><h1 id="条款01：视C-为一个语言联邦"><a href="#条款01：视C-为一个语言联邦" class="headerlink" title="条款01：视C++为一个语言联邦"></a>条款01：视C++为一个语言联邦</h1><p>比较简单的方法是将C++视为一个由相关语言组成的联邦而非单一语言。C++主要由4个联邦组成：</p><ul><li>C。对内置类型而言，pass-by-value通常比pass-by-reference高效。C的局限：没有模板，没有异常，没有重载。</li><li>Object-Oriented C++。对于用户自定义的类型，有构造函数和析构函数的存在，pass-by-reference-to-const效果更好。</li><li>Template C++。同Object-Oriented C++一样。</li><li>STL。在STL中，迭代器和函数对象是再C指针的基础上塑造起来的，所以对STL的迭代器和函数对象而言，pass-by-value守则再次适用。</li></ul><h1 id="条款02：尽量以const，enum，inline替换-define"><a href="#条款02：尽量以const，enum，inline替换-define" class="headerlink" title="条款02：尽量以const，enum，inline替换#define"></a>条款02：尽量以const，enum，inline替换#define</h1><ul><li>对于单纯的变量，最好以const对象或enum替换#define</li><li>对于形式像函数的宏，最好改用inline函数特换#define</li></ul><h1 id="条款03：尽可能使用const"><a href="#条款03：尽可能使用const" class="headerlink" title="条款03：尽可能使用const"></a>条款03：尽可能使用const</h1><ul><li>将某些东西声明为const可帮助编译器侦测出错误的用法。const可被施加于任何作用域内的对象、函数参数、函数返回类型、成员函数本体。</li><li>当const和non-const成员函数有着实质等价的实现时，令non-const版本调用const版本可避免代码重复。</li></ul><p>const语法虽然变化多端，但并不莫测高深。如果关键字const出现在星号左边，表示被指物是常量；如果出现在星号右边，表示指针自身是常量；如果出现在星号两边，表示被指物和指针两者都是常量。</p><p>在const函数中想要改变某些成员变量的方法是：利用C++的一个与const相关的摆动场：mutable（可变的）。mutable释放掉non-static成员变量的bitwise constness约束。</p><h1 id="条款04：确定对象被使用前已先被初始化"><a href="#条款04：确定对象被使用前已先被初始化" class="headerlink" title="条款04：确定对象被使用前已先被初始化"></a>条款04：确定对象被使用前已先被初始化</h1><ul><li>为内置型对象进行手工初始化，因为C++不保证初始化他们。</li><li>构造函数最好使用成员初值列，而不要在构造函数本体内使用赋值操作。初值列列出的成员变量，其排列次序应该和他们在class中的声明次序相同。</li><li>为免除“跨编译单元之初始化次序”问题，请以local static对象提花non-local static对象。</li></ul><h1 id="条款05：了解C-默默编写并调用了哪些函数"><a href="#条款05：了解C-默默编写并调用了哪些函数" class="headerlink" title="条款05：了解C++默默编写并调用了哪些函数"></a>条款05：了解C++默默编写并调用了哪些函数</h1><ul><li>编译器可以暗自为class创建default构造函数、copy函数、copy assignment操作符，以及析构函数。</li></ul><h1 id="条款06：若不想使用编译器自动生成的函数，就该明确拒绝"><a href="#条款06：若不想使用编译器自动生成的函数，就该明确拒绝" class="headerlink" title="条款06：若不想使用编译器自动生成的函数，就该明确拒绝"></a>条款06：若不想使用编译器自动生成的函数，就该明确拒绝</h1><ul><li>为驳回编译器自动提供的机能，可将相应的成员函数声明为private并且不予实现。使用向Uncopyable这样的base class也是一种做法</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法一</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HomeForSale</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//将copy函数和copy assignment函数设置为私有属性</span></span><br><span class="line">    HomeForSale(<span class="keyword">const</span> HomeForSale&amp;);</span><br><span class="line">    HomeForSale&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> HomeForSale&amp;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法二</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Uncopyable</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    Uncopyable()&#123;&#125;</span><br><span class="line">    ~Uncopyable()&#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Uncopyable(<span class="keyword">const</span> Uncopyable&amp;);</span><br><span class="line">    Uncopyable&amp; <span class="keyword">operator</span>=(cosnt Uncopyable&amp;); </span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//继承Uncopyable类</span></span><br><span class="line"><span class="comment">//从而阻止HomeForSale对象被拷贝</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HomeForSale</span>:</span> <span class="keyword">private</span> Uncopyable</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="条款07：为多态基类声明virtual析构函数"><a href="#条款07：为多态基类声明virtual析构函数" class="headerlink" title="条款07：为多态基类声明virtual析构函数"></a>条款07：为多态基类声明virtual析构函数</h1><ul><li>polymorphic（带多态性质的）base classes应该声明一个virtual析构函数。如果class带有任何virtual函数，它就应该拥有一个virtual析构函数。</li><li>classes的设计目的如果不是作为base class来使用，或不是为了具备多态性，就不该声明virtual析构函数。</li></ul><h1 id="条款08：别让异常逃离析构函数"><a href="#条款08：别让异常逃离析构函数" class="headerlink" title="条款08：别让异常逃离析构函数"></a>条款08：别让异常逃离析构函数</h1><ul><li>析构函数绝对不要吐出异常。如果一个析构函数调用的函数可能抛出异常，析构函数应该捕捉任何异常，然后吞下他们（不传播）或结束程序。</li><li>如果客户需要对某个操作函数运行期间抛出的异常做出反应，那么class应该提供一个普通函数（而不是在析构函数中）执行该操作。</li></ul><h1 id="条款09：绝不在构造和析构过程中调用virtual函数"><a href="#条款09：绝不在构造和析构过程中调用virtual函数" class="headerlink" title="条款09：绝不在构造和析构过程中调用virtual函数"></a>条款09：绝不在构造和析构过程中调用virtual函数</h1><ul><li>在构造和析构期间不要调用virtual函数，因为这类调用从不下降至派生类，因为“派生类中的成员变量处于未定义状态”，所以“在基类构造和析构函数期间调用virtual函数不可下降至派生类”。</li></ul><h1 id="条款10：让operator-返回一个reference-to-this"><a href="#条款10：让operator-返回一个reference-to-this" class="headerlink" title="条款10：让operator=返回一个reference to *this"></a>条款10：让operator=返回一个reference to *this</h1><ul><li>这样能够实现“连等”</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    Widget&amp; <span class="keyword">operator</span>= (<span class="keyword">const</span> Widget&amp; rhs)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="条款11：在operator-中处理“自我赋值”"><a href="#条款11：在operator-中处理“自我赋值”" class="headerlink" title="条款11：在operator=中处理“自我赋值”"></a>条款11：在operator=中处理“自我赋值”</h1><ul><li>确保当对象自我赋值时operator=有良好的行为。其中技术包括比较“来源对象”和“目标对象”的地址、精心周到的语句顺序、以及copy-and-swap。</li><li>确定任何函数如果操作一个以上的对象，而其中多个对象是同一个对象时，其行为仍然正确。</li></ul><ul><li>方法一</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bitmap</span>&#123;</span>&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Bitmap* pb;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="keyword">const</span> Widget &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span> == &amp;rhs) <span class="keyword">return</span> *<span class="keyword">this</span>; <span class="comment">//如果是自我赋值，不做任何事</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">delete</span> pb;</span><br><span class="line">    pb = <span class="keyword">new</span> Bitmap(*rhs.pb);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>方法二</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="keyword">const</span> Widget &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">    Bitmap *pOrig = pb; <span class="comment">//记住原来的pb</span></span><br><span class="line">    pb = <span class="keyword">new</span> Bitmap(*rhs.pb);<span class="comment">//令pb指向*pb的一个副本</span></span><br><span class="line">    <span class="keyword">delete</span> pOrig;<span class="comment">//删除原先的pb</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>方法三</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(Widget &amp;rhs)</span></span>;<span class="comment">//交换*this和rhs的数据</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(<span class="keyword">const</span> Widget &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">    Widget temp(rhs);<span class="comment">//为rhs数据制作一个副本</span></span><br><span class="line">    swap(temp);<span class="comment">//将*this数据和上述副本的数据交换</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>方法四<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将复制的操作转移到了“函数参数构造的阶段”</span></span><br><span class="line">Widget&amp; Widget::<span class="keyword">operator</span>=(Widget rhs)<span class="comment">//采用pass by value</span></span><br><span class="line">&#123;</span><br><span class="line">    swap(temp);<span class="comment">//将*this数据和副本的数据交换</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="条款12：复制对象时勿忘记每一个成分"><a href="#条款12：复制对象时勿忘记每一个成分" class="headerlink" title="条款12：复制对象时勿忘记每一个成分"></a>条款12：复制对象时勿忘记每一个成分</h1><ul><li>Copying函数应该确保复制“对象内的所有成员变量”及“所有base class成分”。</li><li>不要尝试以某个copying函数实现另外一个copying函数。应该将共同机能放进第三个函数，并由两个Coping函数共同调用。</li></ul><blockquote><p>所谓资源就是，<strong>一旦用了它，将来必须还给系统</strong>。</p><p><strong>堆</strong>：程序的运行场所是内存，栈和堆是进程的虚拟内存中的两部分区域。当程序被执行，所创建的常量、变量等都会被压入栈空间中。堆是不同于栈的另一个区域，系统会给每个程序分配一部分堆空间，让他们能够运行起来。堆不属于程序，堆是独立的、公用的。栈里的东西有生命周期，就是变量的作用域，而堆里的东西独立于程序，molloc()之后，除非free()掉，否则一直都存在，会造成内存泄漏。</p></blockquote><h1 id="条款13：以对象管理资源"><a href="#条款13：以对象管理资源" class="headerlink" title="条款13：以对象管理资源"></a>条款13：以对象管理资源</h1><ul><li>获得资源后立刻放进管理对象内</li><li>管理对象运行析构函数确保资源释放<blockquote><p>以对象管理资源的观念：资源取得的时机便是初始化时机。（Resource Acquisition Is Initialization; RAII）</p></blockquote></li></ul><ol><li>为防止资源泄漏，请使用RAII对象，他们在构造函数中获得资源并在析构函数中释放资源。</li><li>两个常被使用的RAII class是tr1::shared_ptr和auto_ptr。前者通常是较佳选择，因为其copy行为比较直观。若选择auto_ptr，复制动作会使它指向null。</li></ol><h1 id="条款14：在资源管理类中小心copying行为"><a href="#条款14：在资源管理类中小心copying行为" class="headerlink" title="条款14：在资源管理类中小心copying行为"></a>条款14：在资源管理类中小心copying行为</h1><ul><li>复制RAII对象必须一并复制它所管理的资源，所以资源的copying行为决定了RAII对象的行为。</li><li>常见RAII class copying行为是：抑制copying行为、施行引用计数法。不过其他行为也都是可能被实现的。</li></ul><h1 id="条款15：在资源管理类中提供对原始资源的访问"><a href="#条款15：在资源管理类中提供对原始资源的访问" class="headerlink" title="条款15：在资源管理类中提供对原始资源的访问"></a>条款15：在资源管理类中提供对原始资源的访问</h1><ul><li>APIs往往要求访问原始资源，所以每一个RAII class应该提供一个“取得其所管理的资源”的方法。</li><li>对原始资源的访问可能经由显示转换或隐式转换。一般而言显式转换比较安全，隐式转换对客户比较方便。</li></ul><h1 id="条款16：成对使用new和delete时要采取相同的形式"><a href="#条款16：成对使用new和delete时要采取相同的形式" class="headerlink" title="条款16：成对使用new和delete时要采取相同的形式"></a>条款16：成对使用new和delete时要采取相同的形式</h1><ul><li>如果你在new表达式中使用了[ ]，必须在delete表达式中也使用[ ]，如果你在new表达式中没有使用[ ]，一定不要在delete表达式中使用[ ]。</li></ul><h1 id="条款17：以独立语句将newed指针置入智能指针"><a href="#条款17：以独立语句将newed指针置入智能指针" class="headerlink" title="条款17：以独立语句将newed指针置入智能指针"></a>条款17：以独立语句将newed指针置入智能指针</h1><ul><li>如果不这样做，一旦异常被抛出，有可能导致难以察觉的资源泄漏<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">processWidget(<span class="built_in">std</span>::tr1::<span class="built_in">shared_ptr</span>&lt;Widget&gt;(<span class="keyword">new</span> Widget), priority() );</span><br><span class="line"><span class="comment">//可能造成资源泄漏，</span></span><br><span class="line"><span class="comment">//因为电泳processWidget之前，编译器必须创建代码</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1. 执行“new Widget”</span></span><br><span class="line"><span class="comment">2. 调用priority函数</span></span><br><span class="line"><span class="comment">3. 调用tr1::shared_ptr构造函数</span></span><br><span class="line"><span class="comment">万一调用priority导致异常，会使返回“new Widget”的指针遗失</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::tr1::<span class="built_in">shared_ptr</span>&lt;Widget&gt; pw(<span class="keyword">new</span> Widget);</span><br><span class="line">processWidget(pw, priority() );<span class="comment">//这个调用不会造成资源泄漏</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="条款18：让接口容易被使用，不易被误用"><a href="#条款18：让接口容易被使用，不易被误用" class="headerlink" title="条款18：让接口容易被使用，不易被误用"></a>条款18：让接口容易被使用，不易被误用</h1><ul><li>“促进正确使用”的方法包括接口的一致性，以及与内置类型的行为兼容</li><li>“阻止误用”的方法包括建立新类型、限制类型上的操作，束缚对象值，以及消除客户的资源管理责任</li><li>tr1:::shared_ptr支持定制型删除器。这可以防范DLL（动态链接库）问题，可被用来自动解除互锁等等</li></ul><h1 id="条款19：设计class犹如设计type"><a href="#条款19：设计class犹如设计type" class="headerlink" title="条款19：设计class犹如设计type"></a>条款19：设计class犹如设计type</h1><ul><li>新type的对象应该如何被创建和销毁？</li><li>对象的初始化和对象的复制有什么差别？</li><li>新type对象如果被值传递，意味着什么？</li><li>什么是新type的“合法值”？</li><li>新type需要配合某个继承图系么？</li><li>新type需要什么样的转换？</li><li>什么样的操作符和函数对新type而言是合理的？</li><li>什么样的标准函数应该被驳回？</li><li>谁该取用新type的成员？</li><li>你的新type有多么一般化？</li><li>你真的需要一个新的type么？</li></ul><h1 id="条款20：以pass-by-reference-to-const替换pass-by-value"><a href="#条款20：以pass-by-reference-to-const替换pass-by-value" class="headerlink" title="条款20：以pass-by-reference-to-const替换pass-by-value"></a>条款20：以pass-by-reference-to-const替换pass-by-value</h1><ul><li>尽量以pass-by-reference-to-const替换pass-by-value。前者通常比较高效，并可以避免切割问题。</li><li>以上规则并不适用于内置类型，以及STL的迭代器和函数对象。对他们而言，pass-by-value往往比较适合。</li></ul><h1 id="条款21：必须返回对象时，别妄想返回其reference"><a href="#条款21：必须返回对象时，别妄想返回其reference" class="headerlink" title="条款21：必须返回对象时，别妄想返回其reference"></a>条款21：必须返回对象时，别妄想返回其reference</h1><p>绝不要返回pointer或reference指向一个local stack对象，或返回一个reference指向一个heap-allocated对象，或返回pointer或reference指向一个local static对象而有可能同时需要多个这样的对象。条款4已经为“在单线程环境中合理返回reference指向一个local static对象”提供了一份设计实例。</p><h1 id="条款22：将成员变量声明为private"><a href="#条款22：将成员变量声明为private" class="headerlink" title="条款22：将成员变量声明为private"></a>条款22：将成员变量声明为private</h1><ul><li>切记将成员变量声明为private。这可以赋予客户访问数据的一致性、可细微划分访问控制、允诺约束条件获得保证，并提供class作者以充分的实现弹性。</li><li>protected并不比public更具封装性。private（提供封装）和其他（不提供封装）。</li></ul><h1 id="条款23：宁以non-member、non-friend替换member函数"><a href="#条款23：宁以non-member、non-friend替换member函数" class="headerlink" title="条款23：宁以non-member、non-friend替换member函数"></a>条款23：宁以non-member、non-friend替换member函数</h1><p>这样做可以增加封装性、包裹弹性和扩展性</p><h1 id="条款24：若所有参数皆要类型转换，请为此采用non-member函数"><a href="#条款24：若所有参数皆要类型转换，请为此采用non-member函数" class="headerlink" title="条款24：若所有参数皆要类型转换，请为此采用non-member函数"></a>条款24：若所有参数皆要类型转换，请为此采用non-member函数</h1><h1 id="条款25：考虑写出一个不抛出异常的swap函数"><a href="#条款25：考虑写出一个不抛出异常的swap函数" class="headerlink" title="条款25：考虑写出一个不抛出异常的swap函数"></a>条款25：考虑写出一个不抛出异常的swap函数</h1><blockquote><p>swap置换两对象值，意思是将两对象的值彼此赋予对方。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="built_in">std</span> &#123;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(T&amp; a, T&amp; b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">T <span class="title">temp</span><span class="params">(a)</span></span>;</span><br><span class="line">        a=b;</span><br><span class="line">        b=a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WidgetImpl</span>&#123;</span>...&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        Widget(<span class="keyword">const</span> Widget&amp; rhs);</span><br><span class="line">        Widget&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Widget&amp; rhs)</span><br><span class="line">        &#123;</span><br><span class="line">            *pImpl = *(rhs.pImpl);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        WidgetImpl* pImpl;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当要置换两个Widget对象时，需要做的是置换其成员变量pImpl指针，但swap算法不知道。它只是简单的复制，非常缺乏效率。此时要将std::swap针对Widget特化。<br>我们先在Widget中声明一个名为swap的public成员函数做真正的置换工作，然后再将std::swap特化。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(Widget&amp; other)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">using</span> <span class="built_in">std</span>::swap;</span><br><span class="line">        swap(pImp, other.pImp);</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//std::swap特化版本</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="built_in">std</span>&#123;</span><br><span class="line">    <span class="keyword">template</span>&lt;&gt;</span><br><span class="line">    <span class="keyword">void</span> swap&lt;Widget&gt;(Widget&amp; a, Widget&amp; b)</span><br><span class="line">    &#123;</span><br><span class="line">        a.swap(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="条款26：尽可能延后变量定义式的出现时间"><a href="#条款26：尽可能延后变量定义式的出现时间" class="headerlink" title="条款26：尽可能延后变量定义式的出现时间"></a>条款26：尽可能延后变量定义式的出现时间</h1><blockquote><p>因为只要定义了一个变量，其类型就带有一个构造函数和析构函数，当程序的控制流到达这个变量定义式时，就得承受构造成本，当这个变量离开作用域的时候，就得承受析构成本。即便这个变量没有使用，仍然需要耗费这些成本。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;你的时间有限，所以不要浪费时间去重复别人的生活。&lt;br&gt;Your time is limited, so don’t waste it living someone else’s life.&lt;br&gt;——斯蒂夫.乔布斯
    
    </summary>
    
    
    
      <category term="C++" scheme="http://seaworth.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Qt day01 初识Qt</title>
    <link href="http://seaworth.github.io/2019/06/24/Qt-day01/"/>
    <id>http://seaworth.github.io/2019/06/24/Qt-day01/</id>
    <published>2019-06-24T13:06:05.000Z</published>
    <updated>2019-06-25T12:49:56.032Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>历史上每一个伟大的权威时刻都是热情的胜利。——艾默生<a id="more"></a></p></blockquote><p>学习完C++的基础教程，再学习Qt，让程序有一个漂亮的UI。</p><h1 id="1-Qt概述"><a href="#1-Qt概述" class="headerlink" title="1 Qt概述"></a>1 Qt概述</h1><h2 id="1-1-Qt是什么？"><a href="#1-1-Qt是什么？" class="headerlink" title="1.1 Qt是什么？"></a>1.1 Qt是什么？</h2><p>Qt是一个<strong>跨平台</strong>的C++<strong>图形用户界面应用程序框架</strong>。它为应用程序开发者提供建立艺术级图形界面所需的所有功能。它是完全面向对象的，很容易扩展，并且允许真正的组件编程。</p><h2 id="1-2-Qt支持的平台"><a href="#1-2-Qt支持的平台" class="headerlink" title="1.2 Qt支持的平台"></a>1.2 Qt支持的平台</h2><ul><li>Windows：XP、Vista、Win7、Win8、Win10</li><li>Linux</li><li>Mac OS X</li><li>Embedded：有帧缓冲支持的嵌入式Linux平台</li></ul><h2 id="1-3-Qt的优点"><a href="#1-3-Qt的优点" class="headerlink" title="1.3 Qt的优点"></a>1.3 Qt的优点</h2><ul><li>跨平台，几乎支持所有的平台</li><li>接口简单，容易上手，学习QT框架对学习其他框架有参考意义</li><li>一定程度上简化了内存回收机制 </li><li>开发效率高，能够快速的构建应用程序</li><li>有很好的社区氛围，市场份额在缓慢上升</li><li>可以进行嵌入式开发</li></ul><p>用Qt开发的，比较成功的产品有：Linux的桌面环境KDE、WPS Office办公软件、VirtualBox虚拟机软件</p><h1 id="2-Qt项目中的-pro文件"><a href="#2-Qt项目中的-pro文件" class="headerlink" title="2 Qt项目中的.pro文件"></a>2 Qt项目中的.pro文件</h1><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">QT       += core gui <span class="comment">#包含的模块</span></span><br><span class="line"></span><br><span class="line">greaterThan(QT_MAJOR_VERSION, 4): QT += widgets <span class="comment">#大于QT4版本，才包含widgets模块</span></span><br><span class="line"></span><br><span class="line">TARGET = myFirstQt <span class="comment">#应用程序名，生成exe程序名称</span></span><br><span class="line">TEMPLATE = app <span class="comment">#模板类型，应用程序模板</span></span><br><span class="line">DEFINES += QT_DEPRECATED_WARNINGS </span><br><span class="line">CONFIG += c++11 <span class="comment">#使用c++11的特性</span></span><br><span class="line"></span><br><span class="line">SOURCES += \ <span class="comment">#源文件</span></span><br><span class="line">        main.cpp \</span><br><span class="line">        widget.cpp</span><br><span class="line"></span><br><span class="line">HEADERS += \ <span class="comment">#头文件</span></span><br><span class="line">        widget.h</span><br></pre></td></tr></table></figure><p>.pro就是工程文件（project），它是qmake自动生成的用于生产makefile的配置文件。.pro文件的写法如下：</p><ul><li>注释<br>从“#”开始，到这一行结束。</li><li>模板变量告诉qmake为这个应用程序生成哪种makefile。TEMPLATE = app，建立一个应用程序的makefile，这是默认值。</li><li>greaterThan(QT_MAJOR_VERSION, 4): QT += widgets<br>这条语句的含义是，如果QT_MAJOR_VERSION大于4（也就是当前使用的Qt5及更高版本）需要增加widgets模块。如果项目仅需支持Qt5，也可以直接添加“QT += widgets”一句。不过为了保持代码兼容，最好还是按照QtCreator生成的语句编写。</li></ul><h1 id="3-一个简单的Qt程序"><a href="#3-一个简单的Qt程序" class="headerlink" title="3 一个简单的Qt程序"></a>3 一个简单的Qt程序</h1><p>main入口函数。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"widget.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QApplication&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">    Widget w;</span><br><span class="line">    w.show();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a.exec();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>解释：</p><ul><li>Qt系统提供的标准类名声明头文件没有.h后缀。</li><li>Qt一个类对应一个头文件，类名就是头文件名。</li><li>QApplication应用程序类。管理图形用户界面应用程序的控制流和主要设置，是Qt的整个后台管理的命脉它包含主事件循环，在其中来自窗口系统和其它资源的所有事件处理和调度。它也处理应用程序的初始化和结束，并且提供对话管理。对于任何一个使用Qt的图形用户界面应用程序，都正好存在一个QApplication对象，而不论这个应用程序在同一时间内是不是有0、1、2或更多个窗口。</li><li>a.exec()。程序进入消息循环，等待对用户输入进行响应。这里main()把控制权转交给Qt，Qt完成事件处理工作，当应用程序退出的时候exec()的值就会返回。在exec()中，Qt接受并处理用户和系统的事件并且把它们传递给适当的窗口部件。</li></ul><h1 id="4-信号与槽机制"><a href="#4-信号与槽机制" class="headerlink" title="4 信号与槽机制"></a>4 信号与槽机制</h1><blockquote><p>信号槽是Qt 框架引以为豪的机制之一。所谓信号槽，实际就是观察者模式。当某个事件发生之后，比如，按钮检测到被点击了一下，它就会发出一个信号（signal）。这种发出是没有目的的，类似广播。如果有对象对这个信号感兴趣，它就会使用连接（connect）函数，意思是，将想要处理的信号和自己的一个函数（slot）绑定来处理这个信号。也就是说，当信号发出时，被连接的槽函数会自动被回调。这就类似观察者模式：当发生了感兴趣的事件，某一个操作就会被自动触发。</p></blockquote><h2 id="4-1-系统自带的信号与槽"><a href="#4-1-系统自带的信号与槽" class="headerlink" title="4.1 系统自带的信号与槽"></a>4.1 系统自带的信号与槽</h2><p>connect()函数最常用的一般形式：<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">connect(<span class="name">sender</span>, signal, receiver, slot)<span class="comment">;</span></span><br></pre></td></tr></table></figure></p><p>参数解释：<br>sender：发出信号的对象<br>signal：发送对象发出的信号<br>receiver：接收信号的对象<br>slot：接收对象在接收到信号之后所需要调用的函数（槽函数）</p><h2 id="4-2-Lambda表达式"><a href="#4-2-Lambda表达式" class="headerlink" title="4.2 Lambda表达式"></a>4.2 Lambda表达式</h2><p>C++11中的Lambda表达式用于定义并创建匿名的函数对象，以简化编程工作。<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">capture</span>](<span class="link">parameters</span>) mutable -&gt; return-type</span><br><span class="line">&#123;</span><br><span class="line"><span class="code">statement</span></span><br><span class="line">&#125;</span><br><span class="line">//[<span class="string">函数对象参数</span>](<span class="link">操作符重载函数参数</span>)mutable -&gt;返回值&#123;函数体&#125;</span><br></pre></td></tr></table></figure></p><p>[]，标识一个Lambda的开始，这部分必须存在，<strong>不能省略</strong>。函数对象参数是传递给编译器自动生成的函数对象类的构造函数的。函数对象参数只能使用那些到定义Lambda为止时，Lambda所在作用范围内可见的局部变量（包括Lambda所在类的this）。函数对象参数有以下形式：</p><ul><li>空。没有使用任何函数对象参数。</li><li>=。函数体内可以使用Lambda所在作用范围内所有可见的局部变量（包括Lambda所在类的this），并且是<strong>值传递方式</strong>（相当于编译器自动为我们按值传递了所有局部变量）。这种方式使用的比较多。</li><li>&amp;。函数体内可以使用Lambda所在作用范围内所有可见的局部变量（包括Lambda所在类的this），并且是<strong>引用传递方式</strong>（相当于编译器自动为我们按引用传递了所有局部变量）。</li><li>this。函数体内可以使用Lambda所在类中的成员变量。</li><li>mutable声明，这部分可以省略。按值传递函数对象参数时，加上mutable修饰符后，可以修改按值传递进来的拷贝（注意是能修改拷贝，而不是值本身）。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;历史上每一个伟大的权威时刻都是热情的胜利。——艾默生
    
    </summary>
    
    
    
      <category term="C++" scheme="http://seaworth.github.io/tags/C/"/>
    
      <category term="Qt" scheme="http://seaworth.github.io/tags/Qt/"/>
    
  </entry>
  
  <entry>
    <title>C++ day10 STL常用容器</title>
    <link href="http://seaworth.github.io/2019/05/11/CPP-day10/"/>
    <id>http://seaworth.github.io/2019/05/11/CPP-day10/</id>
    <published>2019-05-11T03:17:46.000Z</published>
    <updated>2019-05-12T08:03:17.723Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>时间和爱都是金钱买不到的，这两样都是伴随人很久的。很幸运能掌握自己的时间，也有足够的金钱做自己想做的事情。——巴菲特<br>做自己想做的事情是最重要的。——芒格<a id="more"></a></p></blockquote><p>STL(Standard Template Library，标准模板库)，是惠普实验室开发的一系列软件的统称。STL 从广义上分为: 容器(container)，算法(algorithm) 迭代器(iterator)，容器和算法之间通过迭代器进行无缝连接。STL具有<strong>高可重用性</strong>，<strong>高性能</strong>，<strong>高移植性</strong>，<strong>跨平台</strong>的优点。</p><h1 id="1-STL三大组件"><a href="#1-STL三大组件" class="headerlink" title="1 STL三大组件"></a>1 STL三大组件</h1><h2 id="1-1-容器"><a href="#1-1-容器" class="headerlink" title="1.1 容器"></a>1.1 容器</h2><p>STL容器就是将运用最广泛的一些数据结构实现出来。<br>常用的数据结构：</p><ul><li>数组(array)</li><li>链表(list)</li><li>树(tree)</li><li>栈(stack)</li><li>队列(queue)</li><li>集合(set)</li><li>映射表(map)</li></ul><p>根据数据在容器中的排列特性，这些数据分为<strong>序列式容器</strong>和<strong>关联式容器</strong>两种。    序列式容器强调值的排序，序列式容器中的每个元素均有固定的位置，除非用删除或插入的操作改变这个位置。vector容器、deque容器、list容器等。    关联式容器是非线性的树结构，更准确的说是二叉树结构。各元素之间没有严格的物理上的顺序关系，也就是说元素在容器中并没有保存元素置入容器时的逻辑顺序。关联式容器另一个显著特点是：在值中选择一个值作为关键字key，这个关键字对值起到索引的作用，方便查找。set/multiset容器 map/multimap容器。</p><h2 id="1-2-算法"><a href="#1-2-算法" class="headerlink" title="1.2 算法"></a>1.2 算法</h2><p>以有限的步骤，解决逻辑或数学上的问题，叫做算法(Algorithms)。STL收录的算法经过了数学上的效能分析与证明，是极具复用价值的，包括常用的排序，查找等等。特定的算法往往搭配特定的数据结构，算法与数据结构相辅相成。</p><h2 id="1-3-迭代器"><a href="#1-3-迭代器" class="headerlink" title="1.3 迭代器"></a>1.3 迭代器</h2><p>迭代器(iterator)是一种抽象的设计概念，现实程序语言中并没有直接对应于这个概念的实物。<code>iterator</code>模式定义如下：提供一种方法，使之能够依序寻访某个容器所含的各个元素，而又无需暴露该容器的内部表示方式。</p><h1 id="2-常用容器"><a href="#2-常用容器" class="headerlink" title="2 常用容器"></a>2 常用容器</h1><h2 id="2-1-string容器"><a href="#2-1-string容器" class="headerlink" title="2.1 string容器"></a>2.1 string容器</h2><h3 id="2-1-1-string的基本概念"><a href="#2-1-1-string的基本概念" class="headerlink" title="2.1.1 string的基本概念"></a>2.1.1 string的基本概念</h3><p>C风格字符串(以空字符<code>\0</code>结尾的字符数组)太过复杂难于掌握，不适合大程序的开发，所以C++标准库定义了一种string类，定义在头文件<string>。<br>string和c风格字符串对比：</string></p><ul><li>char*是一个指针，string是一个类</li><li>string封装了很多实用的成员方法，查找find，拷贝copy，删除delete 替换replace，插入insert</li><li>不用考虑内存释放和越界</li></ul><h3 id="2-1-2-string的常用操作"><a href="#2-1-2-string的常用操作" class="headerlink" title="2.1.2 string的常用操作"></a>2.1.2 string的常用操作</h3><p><a href="http://www.cplusplus.com/reference/string/string/" target="_blank" rel="noopener">string API 官方文档</a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造函数</span></span><br><span class="line"><span class="built_in">string</span> s1;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s2</span><span class="params">(s1)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s3</span><span class="params">(<span class="string">"hello world!"</span>)</span></span>;</span><br><span class="line"><span class="built_in">string</span> s4 = <span class="string">"i love C++."</span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s5</span><span class="params">(<span class="number">3</span>, <span class="string">'6'</span>)</span></span>;<span class="comment">//666</span></span><br></pre></td></tr></table></figure></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//字符串拼接</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s1</span><span class="params">(<span class="string">"hello "</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s2</span><span class="params">(<span class="string">"baby"</span>)</span></span>;</span><br><span class="line">s1 += s2;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">s1.append(<span class="string">", good morning!"</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//字符串的查找</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test04</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">string</span> <span class="title">s1</span>(<span class="params"><span class="string">"abcdefghijk"</span></span>)</span>;</span><br><span class="line"><span class="keyword">int</span> positon;</span><br><span class="line">positon = s1.find(<span class="string">"bc"</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">"position = "</span> &lt;&lt; positon &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> position2;</span><br><span class="line">position2 = s1.rfind(<span class="string">'bc'</span>);<span class="comment">//逆序查找</span></span><br><span class="line">cout &lt;&lt; <span class="string">"position2 = "</span> &lt;&lt; position2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//字符串的替换</span></span><br><span class="line">s1.replace(<span class="number">1</span>, <span class="number">3</span>, <span class="string">"111222"</span>);</span><br><span class="line">cout &lt;&lt; s1 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//string子串</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test06</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">string</span> s1 = <span class="string">"hello world."</span>;</span><br><span class="line"><span class="built_in">string</span> s2 = s1.substr(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//需求：查找邮箱的用户名</span></span><br><span class="line"><span class="built_in">string</span> email = <span class="string">"baichuanemail@qq.com"</span>;</span><br><span class="line"><span class="keyword">int</span> position = email.find(<span class="string">"@"</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; position &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">string</span> userName=email.substr(<span class="number">0</span>,position);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"userName = "</span> &lt;&lt; userName &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//练习：验证码中不区分大小写，内部进行了大小写的转换（都转换为大写或都转换为小写）</span></span><br><span class="line"><span class="comment">//函数内部将string字符串中的所有小写字母都变为大写字母。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test10</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">string</span> s1 = <span class="string">"aBcDeFgH"</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;c : s1)</span><br><span class="line">&#123;</span><br><span class="line">c = <span class="built_in">toupper</span>(c);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> c : s1)</span><br><span class="line">&#123;</span><br><span class="line">c = <span class="built_in">tolower</span>(c);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-2-vector容器"><a href="#2-2-vector容器" class="headerlink" title="2.2 vector容器"></a>2.2 vector容器</h2><h3 id="2-2-1-vector容器基本概念"><a href="#2-2-1-vector容器基本概念" class="headerlink" title="2.2.1 vector容器基本概念"></a>2.2.1 vector容器基本概念</h3><p>vector的数据安排以及操作方式，与array非常相似，两者的唯一差别在于空间的运用的灵活性。array是静态空间，一旦配置了就不能改变，要换大一点或者小一点的空间，一切琐碎得由自己来，首先配置一块新的空间，然后将旧空间的数据搬往新空间，再释放原来的空间。vector是动态空间，随着元素的加入，它的内部机制会自动扩充空间以容纳新元素。</p><p><img src="1.png" width="50%" height="50%" alt="vector容器"></p><h3 id="2-2-2-vector迭代器"><a href="#2-2-2-vector迭代器" class="headerlink" title="2.2.2 vector迭代器"></a>2.2.2 vector迭代器</h3><p>vector维护一个线性空间，所以不论元素的型别如何，普通指针都可以作为vector的迭代器，vector支持随机存取。</p><h3 id="2-2-3-vector数据结构"><a href="#2-2-3-vector数据结构" class="headerlink" title="2.2.3 vector数据结构"></a>2.2.3 vector数据结构</h3><p>vector所采用的数据结构非常简单，线性连续空间，它以两个迭代器_Myfirst和_Mylast分别指向配置得来的连续空间中目前已被使用的范围，并以迭代器_Myend指向整块连续内存空间的尾端。<br>为了降低空间配置时的速度成本，vector实际配置的大小可能比客户端需求大一些，以备将来可能的扩充，这边是容量的概念。换句话说，<strong>一个vector的容量永远大于或等于其大小，一旦容量等于大小，便是满载，下次再有新增元素，整个vector容器就得另觅居所。</strong></p><h3 id="2-2-4-vector常用API"><a href="#2-2-4-vector常用API" class="headerlink" title="2.2.4 vector常用API"></a>2.2.4 vector常用API</h3><p><a href="http://www.cplusplus.com/reference/vector/vector/?kw=vector" target="_blank" rel="noopener">string API 官方文档</a></p><h2 id="2-3-deque容器"><a href="#2-3-deque容器" class="headerlink" title="2.3 deque容器"></a>2.3 deque容器</h2><h3 id="2-3-1-deque容器基本概念"><a href="#2-3-1-deque容器基本概念" class="headerlink" title="2.3.1 deque容器基本概念"></a>2.3.1 deque容器基本概念</h3><p>vector容器是单向开口的连续内存空间，deque则是一种双向开口的连续线性空间。所谓的双向开口，意思是可以在头尾两端分别做元素的插入和删除操作，当然，vector容器也可以在头尾两端插入元素，但是在其头部操作效率很差，无法被接受。<br>deque容器和vector容器最大的差异，一在于deque允许使用常数项时间对头端进行元素的插入和删除操作。二在于deque没有容量的概念，因为它是动态的以分段连续空间组合而成，随时可以增加一段新的空间并链接起来。deque容器的复杂度远高于vector，除非有必要，尽可能使用vector，而不是deque。对deque进行的排序操作，为了最高效率，可将deque先完整的复制到一个vector中，对vector容器进行排序，再复制回deque。</p><p><img src="2.png" width="50%" height="50%" alt="deque容器"></p><p>deque是由一段一段的定量的连续空间构成。一旦有必要在deque前端或者尾端增加新的空间，便配置一段连续定量的空间，串接在deque的头端或者尾端。deque最大的工作就是维护这些分段连续的内存空间的整体性的假象，并提供随机存取的接口，避开了重新配置空间，复制，释放的轮回，代价就是复杂的迭代器架构。<br>既然deque是分段连续内存空间，那么就必须有中央控制，维持整体连续的假象，数据结构的设计及迭代器的前进后退操作颇为繁琐。deque代码的实现远比vector或list都多得多。</p><h3 id="2-3-2-deque常用API"><a href="#2-3-2-deque常用API" class="headerlink" title="2.3.2 deque常用API"></a>2.3.2 deque常用API</h3><p><a href="http://www.cplusplus.com/reference/deque/deque/?kw=deque" target="_blank" rel="noopener">deque API 官方文档</a></p><h2 id="2-4-stack容器"><a href="#2-4-stack容器" class="headerlink" title="2.4 stack容器"></a>2.4 stack容器</h2><h3 id="2-4-1-stack容器基本概念"><a href="#2-4-1-stack容器基本概念" class="headerlink" title="2.4.1 stack容器基本概念"></a>2.4.1 stack容器基本概念</h3><p>stack是一种先进后出(First In Last Out，FILO)的数据结构，它只有一个出口，形式如图所示。stack容器允许新增元素，移除元素，取栈顶元素，但是除了最顶端外，没有任何其他方法可以存取stack的其他元素。换言之，stack不提供遍历功能，也不提供迭代器。<br>有元素推入栈的操作称为push，将元素推出stack的操作称为pop。</p><p><img src="3.png" width="30%" height="30%" alt="stack容器"></p><h3 id="2-4-2-stack容器常用API"><a href="#2-4-2-stack容器常用API" class="headerlink" title="2.4.2 stack容器常用API"></a>2.4.2 stack容器常用API</h3><p><a href="http://www.cplusplus.com/reference/stack/stack/?kw=stack" target="_blank" rel="noopener">stack API 官方文档</a></p><h2 id="2-5-queue容器"><a href="#2-5-queue容器" class="headerlink" title="2.5 queue容器"></a>2.5 queue容器</h2><h3 id="2-5-1-queue容器基本概念"><a href="#2-5-1-queue容器基本概念" class="headerlink" title="2.5.1 queue容器基本概念"></a>2.5.1 queue容器基本概念</h3><p>queue是一种先进先出(First In First Out，FIFO)的数据结构，它有两个出口，queue容器允许从一端新增元素，从另一端移除元素。queue不提供遍历功能，也不提供迭代器。</p><p><img src="4.png" width="50%" height="50%" alt="queue容器"></p><h3 id="2-5-2-queue容器常用API"><a href="#2-5-2-queue容器常用API" class="headerlink" title="2.5.2 queue容器常用API"></a>2.5.2 queue容器常用API</h3><p><a href="http://www.cplusplus.com/reference/queue/queue/?kw=queue" target="_blank" rel="noopener">queue API 官方文档</a></p><h2 id="2-6-list容器"><a href="#2-6-list容器" class="headerlink" title="2.6 list容器"></a>2.6 list容器</h2><h3 id="2-6-1-list容器基本概念"><a href="#2-6-1-list容器基本概念" class="headerlink" title="2.6.1 list容器基本概念"></a>2.6.1 list容器基本概念</h3><p>链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的<strong>指针</strong>链接次序实现的。链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。<br>相较于vector的连续线性空间，list就显得负责许多，它的好处是每次插入或者删除一个元素，就是配置或者释放一个元素的空间。因此，list对于空间的运用有绝对的精准，一点也不浪费。而且，对于任何位置的元素插入或元素的移除，list永远是常数时间。<br><strong>list和vector是两个最常被使用的容器。</strong></p><p><img src="5.png" width="50%" height="50%" alt="list容器"></p><ul><li>采用动态存储分配，不会造成内存浪费和溢出</li><li>链表执行插入和删除操作十分方便，修改指针即可，不需要移动大量元素</li><li>链表灵活，但是空间和时间额外耗费较大</li></ul><h3 id="2-6-2-list容器常用API"><a href="#2-6-2-list容器常用API" class="headerlink" title="2.6.2 list容器常用API"></a>2.6.2 list容器常用API</h3><p><a href="http://www.cplusplus.com/reference/list/list/?kw=list" target="_blank" rel="noopener">list API 官方文档</a></p><h2 id="2-7-set-mutliset容器"><a href="#2-7-set-mutliset容器" class="headerlink" title="2.7 set/mutliset容器"></a>2.7 set/mutliset容器</h2><h3 id="2-7-1-set-mutliset容器基本概念"><a href="#2-7-1-set-mutliset容器基本概念" class="headerlink" title="2.7.1 set/mutliset容器基本概念"></a>2.7.1 set/mutliset容器基本概念</h3><p>set的特性：所有元素都会根据元素的键值自动被排序。set的元素不像map那样可以同时拥有实值和键值，set的元素即是键值又是实值。set不允许两个元素有相同的键值。可以通过set的迭代器改变set元素的值吗？<strong>不行</strong>，因为set元素值就是其键值，关系到set元素的排序规则。如果任意改变set元素值，会严重破坏set组织。换句话说，set的iterator是一种<strong>const_iterator</strong>。<br>multiset特性及用法和set完全相同，唯一的差别在于它允许键值重复。set和multiset的底层实现是红黑树，<strong>红黑树</strong>为平衡二叉树的一种。</p><h3 id="2-7-2-set-mutliset容器常用API"><a href="#2-7-2-set-mutliset容器常用API" class="headerlink" title="2.7.2 set/mutliset容器常用API"></a>2.7.2 set/mutliset容器常用API</h3><p><a href="http://www.cplusplus.com/reference/set/set/?kw=set" target="_blank" rel="noopener">set API 官方文档</a></p><h3 id="2-7-3-pair对组"><a href="#2-7-3-pair对组" class="headerlink" title="2.7.3 pair对组"></a>2.7.3 pair对组</h3><p>对组(pair)将一对值组合成一个值，这一对值可以具有不同的数据类型，两个值可以分别用pair的两个公有属性first和second访问。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一种方法创建一个对组</span></span><br><span class="line">pair&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; pair1(<span class="built_in">string</span>(<span class="string">"name"</span>), <span class="number">20</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; pair1.first &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//访问pair第一个值</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; pair1.second &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//访问pair第二个值</span></span><br><span class="line"><span class="comment">//第二种</span></span><br><span class="line">pair&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; pair2 = make_pair(<span class="string">"name"</span>, <span class="number">30</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; pair2.first &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; pair2.second &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></p><h2 id="2-8-map-multimap容器"><a href="#2-8-map-multimap容器" class="headerlink" title="2.8 map/multimap容器"></a>2.8 map/multimap容器</h2><h3 id="2-8-1-map-multimap容器基本概念"><a href="#2-8-1-map-multimap容器基本概念" class="headerlink" title="2.8.1 map/multimap容器基本概念"></a>2.8.1 map/multimap容器基本概念</h3><p>map的特性是，所有元素都会根据元素的键值key自动排序。map所有的元素都是pair，同时拥有键值key和实值value，pair的第一元素被视为键值key，第二元素为实值value，map不允许两个元素有相同的键值。<br>我们可以通过map的迭代器改变map的键值吗？不行，因为map的键值关系到map元素的排列规则，任意改变map键值将会严重破坏map组织。如果想要修改元素的实值，那么是可以的。<br>multimap和map的操作类似，唯一区别multimap键值可重复。<br>Map和multimap都是以<strong>红黑树</strong>为底层实现机制。</p><h3 id="2-8-2-map-multimap容器常用API"><a href="#2-8-2-map-multimap容器常用API" class="headerlink" title="2.8.2 map/multimap容器常用API"></a>2.8.2 map/multimap容器常用API</h3><p><a href="http://www.cplusplus.com/reference/map/map/?kw=map" target="_blank" rel="noopener">map API 官方文档</a></p><h1 id="3-STL容器使用时机"><a href="#3-STL容器使用时机" class="headerlink" title="3 STL容器使用时机"></a>3 STL容器使用时机</h1><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">vector</th><th style="text-align:center">deque</th><th style="text-align:center">list</th><th style="text-align:center">set</th><th style="text-align:center">multiset</th><th style="text-align:center">map</th><th style="text-align:center">multimap</th></tr></thead><tbody><tr><td style="text-align:center">典型内存结构</td><td style="text-align:center">单端数组</td><td style="text-align:center">双端数组</td><td style="text-align:center">双向链表</td><td style="text-align:center">二叉树</td><td style="text-align:center">二叉树</td><td style="text-align:center">二叉树</td><td style="text-align:center">二叉树</td></tr><tr><td style="text-align:center">可随机存取</td><td style="text-align:center">是</td><td style="text-align:center">是</td><td style="text-align:center">否</td><td style="text-align:center">否</td><td style="text-align:center">否</td><td style="text-align:center">对key而言，不是</td><td style="text-align:center">否</td></tr><tr><td style="text-align:center">元素搜寻速度</td><td style="text-align:center">慢</td><td style="text-align:center">慢</td><td style="text-align:center">非常慢</td><td style="text-align:center">快</td><td style="text-align:center">快</td><td style="text-align:center">对key而言，快</td><td style="text-align:center">对key而言，快</td></tr><tr><td style="text-align:center">元素安插移除</td><td style="text-align:center">尾端</td><td style="text-align:center">头尾两端</td><td style="text-align:center">任何位置</td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">-</td><td style="text-align:center">-</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;时间和爱都是金钱买不到的，这两样都是伴随人很久的。很幸运能掌握自己的时间，也有足够的金钱做自己想做的事情。——巴菲特&lt;br&gt;做自己想做的事情是最重要的。——芒格
    
    </summary>
    
    
    
      <category term="C++" scheme="http://seaworth.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++ day09 异常处理、标准IO流、文件读写</title>
    <link href="http://seaworth.github.io/2019/04/18/CPP-day09/"/>
    <id>http://seaworth.github.io/2019/04/18/CPP-day09/</id>
    <published>2019-04-18T12:34:07.000Z</published>
    <updated>2019-04-21T08:48:31.763Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>我希望每个程序员都能够明白工作、技术、写代码这些并不是你存在的意义，而生活才是，你需要懂得生活，学会生活。</p><ul><li>生活：尝试有节制和有规律地生活，程序员生涯绝不是一次冲刺跑，而是一场马拉松。</li><li>睡眠：请记住保证充足的睡眠将使你变得更加强大。</li><li>旅行：这能够让你发现和感受到新的东西和事物，而这些无法从电脑屏幕上获取。<br>——《程序员的自我修养》<a id="more"></a></li></ul></blockquote><h1 id="0-类型转换"><a href="#0-类型转换" class="headerlink" title="0 类型转换"></a>0 类型转换</h1><blockquote><p>向上类型转换和向下类型转化：如下图所示，父类在上，子类在下。父类对象向子类转换，称向下类型转换，不安全。子类对象向父类转换，称向上类型转换，安全。安全与不安全的界定：指针是否指向了未知的区域，如果有则不安全。</p></blockquote><p><strong>发生多态时，向上类型转换和向下类型转换总是安全的。因为一开始就给基类指针分配了派生类大小的内存空间，向上类型转换后，不会超出分配的内存空间，所以是安全的。</strong><br><img src="/2019/04/18/CPP-day09/1.png" title="向上向下类型转换"></p><p>命名的强制类型转换<br>转换的形式如下：<br><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">cast</span>-name&lt;<span class="keyword">type</span>&gt;(expression);</span><br></pre></td></tr></table></figure></p><p>其中，<em>type</em>是装换的目标类型，<em>expression</em>是要转换的值。<em>cast-name</em>是<strong>static_cast</strong>，<strong>dynamic_cast</strong>，<strong>const_cast</strong>，<strong>reinterpret_cast</strong>中的一种。<em>cast-name</em>指定了执行的是哪种转换。</p><p><strong>静态转换static_cast</strong><br>任何具有明确定义的类型转换，只要不包含底层的const，都可以使用<em>static_cast</em>。当需要把一个较大的算数类型赋值给较小的类型时，static_cast非常有用。此时，强制类型转换告诉程序的读者和编译器：我们知道并且不在乎潜在的精度损失。</p><p><strong>动态类型转换dynamic_cast</strong><br>基础类型都不可以转换，因为这会导致失去精度和不安全，都不让转换，非常严格。在进行下行转换的时候，<strong>dynamic_cast</strong>具有类型检查的功能，比static_cast更安全。</p><p><strong>dynamic_cast</strong> 如果发生了多态，可以让基类转化为子类，向下转换，因为发生多态时，向上类型转换和向下类型转换总是安全的。</p><p><strong>常量转换const_cast</strong><br>不能直接对非指针和非引用进行常量转换。const_cast只能改变运算对象底层的const。</p><p><strong>建议：避免强制类型转换，因为干扰了正常的类型检查。</strong></p><h1 id="1-异常处理"><a href="#1-异常处理" class="headerlink" title="1 异常处理"></a>1 异常处理</h1><blockquote><p>异常是指在运行时的反常行为，这些行为超出了函数的正常功能。</p></blockquote><p>异常处理包括：</p><ul><li>throw表达式，异常检测使用throw表达式来表示它所遇到无法处理的问题。throw抛出异常。</li><li>try语句块，用来处理异常。try语句块以try开始，一个或多个catch子句结束。</li></ul><p>异常的捕捉方式是通过严格类型匹配。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestFunction</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"开始抛出异常..."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//throw 10; //抛出int类型异常</span></span><br><span class="line"><span class="comment">//throw 'a'; //抛出char类型异常</span></span><br><span class="line"><span class="comment">//throw "abcd"; //抛出char*类型异常</span></span><br><span class="line"><span class="built_in">string</span> ex = <span class="string">"string exception!"</span>;</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">TestFunction();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (<span class="keyword">int</span>)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"抛出Int类型异常!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (<span class="keyword">char</span>)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"抛出Char类型异常!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (<span class="keyword">char</span>*)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"抛出Char*类型异常!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (<span class="built_in">string</span>)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"抛出string类型异常!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//捕获所有异常</span></span><br><span class="line"><span class="keyword">catch</span> (...)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"抛出其他类型异常!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>异常接口声明：<br>在函数声明中列出可能抛出异常的所有类型，例如：void func() throw(A,B,C);这个函数func能够且只能抛出类型A,B,C<br>一个不抛任何类型异常的函数可声明为:void func() throw()<br>在VS环境下测试不成功，只有在<code>QT</code>和<code>Linux</code>下测试成功。</p><p>使用系统的标准异常，需要包含头文件<code>#include &lt;stdexcept&gt;</code></p><p><strong>05 使用系统的标准异常.cpp</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; //标准输入输出流</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;<span class="comment">//使用命名空间 std</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Person(<span class="built_in">string</span> in_name, <span class="keyword">int</span> in_age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;name = in_name;</span><br><span class="line"><span class="keyword">if</span> (in_age&lt;<span class="number">0</span> || in_age&gt;<span class="number">200</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//throw out_of_range("范围越界");</span></span><br><span class="line"><span class="keyword">throw</span> length_error(<span class="string">"长度越界"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>-&gt;age = in_age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> name;</span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">"seaworth"</span>, <span class="number">201</span>)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (out_of_range error)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; error.what() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (length_error error)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; error.what() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//函数入口</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">test01();</span><br><span class="line">system(<span class="string">"pause"</span>);<span class="comment">//阻塞功能</span></span><br><span class="line"><span class="keyword">return</span> EXIT_SUCCESS;<span class="comment">//返回正常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="2-标准输入输出流"><a href="#2-标准输入输出流" class="headerlink" title="2 标准输入输出流"></a>2 标准输入输出流</h1><p><strong>程序的输入</strong>指的是从输入文件将数据传送给程序，<strong>程序的输出</strong>指的是从程序将数据传送给输出文件。<br>对系统指定的标准设备的输入和输出。即从键盘输入数据，输出到显示器屏幕。这种输入输出称为标准的输入输出，简称<strong>标准I/O</strong>。<br>以外存磁盘文件为对象进行输入和输出，即从磁盘文件输入数据，数据输出到磁盘文件。以外存文件为对象的输入输出称为文件的输入输出，简称<strong>文件I/O</strong>。</p><h2 id="2-1-标准输入流"><a href="#2-1-标准输入流" class="headerlink" title="2.1 标准输入流"></a>2.1 标准输入流</h2><p>标准输入流对象cin，重点掌握的函数：<br>cin.get() //一次只能读取一个字符<br>cin.get(一个参数) //读一个字符<br>cin.get(两个参数) //可以读字符串，不会将换行符拿走，留在了缓冲区中<br>cin.getline() //读取一行数据，将换行符拿走<br>cin.ignore()  //参数为空的时候，默认忽略1，参数为n时，忽略n个字符<br>cin.peek()      //偷窥<br>cin.putback() //放回</p><blockquote><p>小案例：设计一个函数，让用户输入0-9，如果输入错误，重新输入</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入0-9："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">int</span> num;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; num;</span><br><span class="line"><span class="keyword">if</span> (num &gt;= <span class="number">0</span> &amp;&amp; num &lt;= <span class="number">9</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"输入正确："</span> &lt;&lt; num &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"请重新输入0-9："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//重置标志位</span></span><br><span class="line"><span class="built_in">cin</span>.clear();</span><br><span class="line"><span class="comment">//清除缓冲区</span></span><br><span class="line"><span class="built_in">cin</span>.sync();</span><br><span class="line"><span class="comment">//cout &lt;&lt; "标志位：" &lt;&lt; cin.fail() &lt;&lt; endl;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：需要重置标志位cin.clear()，清除缓冲区cin.sync()，不然标志位被破坏，导致程序死循环。cin.fail()可以查看标志位，0表示正常，1表示不正常。</p><h2 id="2-2-标准输出流"><a href="#2-2-标准输出流" class="headerlink" title="2.2 标准输出流"></a>2.2 标准输出流</h2><p>字符输出<br>cout.put()   //向缓冲区写字符<br>cout.write() //从buffer中写num个字节到当前输出流中。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span>.put(<span class="string">'a'</span>).put(<span class="string">'b'</span>).put(<span class="string">'\n'</span>);<span class="comment">//可以链式输出</span></span><br><span class="line"><span class="keyword">char</span> buff[<span class="number">1024</span>] = <span class="string">"hello world"</span>;</span><br><span class="line"><span class="built_in">cout</span>.write(buff,<span class="built_in">strlen</span>(buff));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过流成员函数，格式化输出<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> number = <span class="number">99</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>.width(<span class="number">20</span>);<span class="comment">//宽度为20</span></span><br><span class="line"><span class="built_in">cout</span>.fill(<span class="string">'*'</span>);<span class="comment">//空白填充*</span></span><br><span class="line"><span class="built_in">cout</span>.setf(ios::left);<span class="comment">//设置左对齐</span></span><br><span class="line"><span class="built_in">cout</span>.unsetf(ios::dec); <span class="comment">//卸载十进制</span></span><br><span class="line"><span class="built_in">cout</span>.setf(ios::hex);<span class="comment">//安装8进制</span></span><br><span class="line"><span class="built_in">cout</span>.setf(ios::showbase);<span class="comment">//强制输出八进制，0，0x打头</span></span><br><span class="line"><span class="built_in">cout</span>.unsetf(ios::hex);<span class="comment">//卸载8进制</span></span><br><span class="line"><span class="built_in">cout</span>.setf(ios::oct);<span class="comment">//安装16进制</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; number &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果：<br><img src="/2019/04/18/CPP-day09/2.png" title="运行结果"></p><h1 id="3-文件读写"><a href="#3-文件读写" class="headerlink" title="3 文件读写"></a>3 文件读写</h1><p>输入输出是以系统指定的标准设备（输入设备为键盘，输出设备为显示器）为对象的。在实际应用中，常以磁盘文件作为对象。即从磁盘文件读取数据，将数据输出到磁盘文件。需要包含头文件<code>#include &lt;fstream&gt;</code>，这个头文件主要定义了三个类，ifstream，ofstream，fstream。由于文件设备并不像显示器屏幕与键盘那样是标准默认设备，所以它在fstream头文件中是没有像cout那样预先定义的全局对象，所以我们必须自己定义一个该类的对象。ifstream类，它是从istream类派生的，用来支持从磁盘文件的输入。ofstream类，它是从ostream类派生的，用来支持向磁盘文件的输出。fstream类，它是从iostream类派生的，用来支持对磁盘文件的输入输出。</p><p>文件输入输出方式设置值：<br>ios::out 以输出方式打开文件，如已有此名字的文件，则将其原内容全部清除。<br>ios::trunc 打开一个文件，如果存在，则将内容清除，如果不存在，则创建新文件。<br>ios::in 以默认的方式打开文件。</p><p><strong>09 文件的读写操作.cpp</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; //标准输入输出流</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;<span class="comment">//使用命名空间 std</span></span><br><span class="line"><span class="comment">//包含读写文件的头文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function">ofstream <span class="title">outFile</span><span class="params">(<span class="string">"./test.txt"</span>, ios::out | ios::trunc)</span></span>;</span><br><span class="line"><span class="comment">//判断是否打开成功</span></span><br><span class="line"><span class="keyword">if</span> (!outFile.is_open())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"打开失败"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">outFile &lt;&lt; <span class="string">"name: seaworth"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">outFile &lt;&lt; <span class="string">"age : 23"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">outFile &lt;&lt; <span class="string">"id  : 001"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//关闭文件</span></span><br><span class="line">outFile.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取文件</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ifstream inFile;</span><br><span class="line">inFile.open(<span class="string">"./test.txt"</span>, ios::in);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!inFile.is_open())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"打开失败"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1 第一种方式</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line"><span class="keyword">char</span> buff[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">while</span> (inFile &gt;&gt; buff)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; buff &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">//2 第二种方式</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line"><span class="keyword">char</span> buff2[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">while</span> (!inFile.eof())<span class="comment">//eof读到文件尾</span></span><br><span class="line">&#123;</span><br><span class="line">inFile.getline(buff2, <span class="keyword">sizeof</span>(buff2));</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; buff2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">//3 第三种方式(不推荐)</span></span><br><span class="line"><span class="keyword">char</span> c;</span><br><span class="line"><span class="keyword">while</span> ((c = inFile.get()) != EOF)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; c;</span><br><span class="line">&#125;</span><br><span class="line">inFile.close();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//函数入口</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//test01();</span></span><br><span class="line">test02();</span><br><span class="line"></span><br><span class="line">system(<span class="string">"pause"</span>);<span class="comment">//阻塞功能</span></span><br><span class="line"><span class="keyword">return</span> EXIT_SUCCESS;<span class="comment">//返回正常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果：<br><img src="/2019/04/18/CPP-day09/3.png" title="运行结果"></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;我希望每个程序员都能够明白工作、技术、写代码这些并不是你存在的意义，而生活才是，你需要懂得生活，学会生活。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;生活：尝试有节制和有规律地生活，程序员生涯绝不是一次冲刺跑，而是一场马拉松。&lt;/li&gt;
&lt;li&gt;睡眠：请记住保证充足的睡眠将使你变得更加强大。&lt;/li&gt;
&lt;li&gt;旅行：这能够让你发现和感受到新的东西和事物，而这些无法从电脑屏幕上获取。&lt;br&gt;——《程序员的自我修养》
    
    </summary>
    
    
    
      <category term="C++" scheme="http://seaworth.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++ day08 模板</title>
    <link href="http://seaworth.github.io/2019/04/14/CPP-day08/"/>
    <id>http://seaworth.github.io/2019/04/14/CPP-day08/</id>
    <published>2019-04-14T03:06:39.000Z</published>
    <updated>2019-04-14T08:37:05.936Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>谁控制过去，谁就控制未来；谁控制现在，谁就控制过去。——《1984》<a id="more"></a></p></blockquote><h1 id="1-函数模板"><a href="#1-函数模板" class="headerlink" title="1 函数模板"></a>1 函数模板</h1><p>C++提供了函数模板(function template)，所谓函数模板，实际上是建立一个通用函数，其函数类型和形参类型不具体制定，用一个虚拟的类型来代表。这个通用函数就成为函数模板。凡是函数体相同的函数，但是参数的类型不同，都可以用这个模板代替，不必定义多个函数，只需在模板中定义一次即可。在调用函数时系统会根据实参的类型来取代模板中的虚拟类型，从而实现不同函数的功能。</p><h2 id="1-1-函数模板基本用法"><a href="#1-1-函数模板基本用法" class="headerlink" title="1.1 函数模板基本用法"></a>1.1 函数模板基本用法</h2><p>设计一个函数，功能是交换两个变量的值。其基本的用法如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; //同<span class="title">template</span>&lt;typename T&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">mySwap</span>(<span class="title">T</span> &amp;<span class="title">a1</span>, <span class="title">T</span> &amp;<span class="title">a2</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">T temp = a1;<span class="comment">//声明一个临时值</span></span><br><span class="line">a1 = a2;</span><br><span class="line">a2 = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>调用以上的函数模板，有两种方式：</p><ol><li>自动类型推导</li><li>显示类型调用</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a1 = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> a2 = <span class="number">30</span>;</span><br><span class="line"><span class="comment">//1自动类型推导</span></span><br><span class="line">mySwap(a1, a2);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"a1= "</span> &lt;&lt; a1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"a2= "</span> &lt;&lt; a2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2显式类型调用</span></span><br><span class="line">mySwap&lt;<span class="keyword">int</span>&gt;(a1, a2);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"a1= "</span> &lt;&lt; a1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"a2= "</span> &lt;&lt; a2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数模板与普通函数的区别：函数模板不可以进行隐式类型转换，而普通函数可以进行隐式类型转化。</p><p>函数模板和普通函数的调用规则：</p><ol><li>如果函数模板和普通函数重载（同名），优先调用普通函数，如果要强制调用函数模板，可以使用空参数列表myPrint&lt;&gt;(a,b)。</li><li>函数模板可以发生重载。</li><li>如果函数模板可以产生更好的匹配时，优先调用函数模板。</li></ol><h2 id="1-2-模板实现的机制"><a href="#1-2-模板实现的机制" class="headerlink" title="1.2 模板实现的机制"></a>1.2 模板实现的机制</h2><p>HelloWorld.cpp是高级语言程序，是方便人阅读和编写，机器是不能够直接识别的，机器只能够识别机器指令（二进制文件）。为了在系统上能够运行HelloWorld.cpp程序，每一条语句都需要转化为机器指令。然后将这些机器指令打包成可执行目标文件格式，并以二进制形式存储在磁盘中。</p><p>预处理(Pre-processing)<code>-&gt;</code>编译(Compiling)<code>-&gt;</code>汇编(Assembling)<code>-&gt;</code>链接(Linking)</p><p>函数模板机制，并不是通过把函数模板处理成任何类型的函数，只是通过传递的类型参数生成不同的函数，编译器会对函数模板进行<strong>两次编译</strong>，在声明的地方对模板代码本身进行编译，在调用的地方对参数替换后的代码进行编译。</p><h2 id="1-3-模板的局限性和解决方法"><a href="#1-3-模板的局限性和解决方法" class="headerlink" title="1.3 模板的局限性和解决方法"></a>1.3 模板的局限性和解决方法</h2><p>假设有如下函数模板，用来比较两个对象是否相等。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">template&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">bool myCompare(T &amp;a, T &amp;b)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (a == b)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当调用函数模板的时候，传入的是自定义参数类型<code>class Person</code>，该函数则无法正确处理。为了解决这种问题，可以提供模板的重载，为这些特定的类型提供具体化的模板。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">bool</span> myCompare&lt;Person&gt;(Person &amp;a, Person &amp;b)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (a.age == b.age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="2-类模板"><a href="#2-类模板" class="headerlink" title="2 类模板"></a>2 类模板</h1><h1 id="2-1-类模板基本用法"><a href="#2-1-类模板基本用法" class="headerlink" title="2.1 类模板基本用法"></a>2.1 类模板基本用法</h1><p>类模板和函数模板的定义和使用相似。有时候，两个类的功能相同，仅仅数据类型不同，则可以使用类模板。用法如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">nameType</span>,<span class="title">class</span> <span class="title">ageType</span>=<span class="title">int</span>&gt;//如果没有传递类型，则默认为<span class="title">int</span></span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Person(nameType in_name, ageType in_age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;name = in_name;</span><br><span class="line"><span class="keyword">this</span>-&gt;age = in_age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"name: "</span> &lt;&lt; <span class="keyword">this</span>-&gt;name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"age: "</span> &lt;&lt; <span class="keyword">this</span>-&gt;age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">nameType name;</span><br><span class="line">ageType age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Person&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; p1(<span class="string">"孙悟空"</span>, <span class="number">1000</span>);</span><br><span class="line">Person&lt;<span class="built_in">string</span>&gt; p2(<span class="string">"猪八戒"</span>, <span class="number">2000</span>);<span class="comment">//默认类型</span></span><br><span class="line">p1.show();</span><br><span class="line">p2.show();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>类模板：</p><ol><li>可以有默认的类型</li><li>类模板不可以类型推导，只能够显式调用</li></ol><h1 id="2-2-类模板做函数参数"><a href="#2-2-类模板做函数参数" class="headerlink" title="2.2 类模板做函数参数"></a>2.2 类模板做函数参数</h1><p>三种使用方式：</p><ol><li>指定传入类型</li><li>参数模板化</li><li>整体模板化</li></ol><blockquote><p>小技巧：typeid().name() 打印变量的类型</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 指定传入类型</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doWork1</span><span class="params">(Person&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; &amp;p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">p.show();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Person&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; p(<span class="string">"aa"</span>, <span class="number">12</span>);</span><br><span class="line">doWork1(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2. 参数模板化</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>,<span class="title">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">doWork2</span>(<span class="title">Person</span>&lt;T1, T2&gt; &amp;<span class="title">p</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">typeid</span>(T1).name() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">typeid</span>(T2).name() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">p.show();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Person&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; p(<span class="string">"bb"</span>, <span class="number">13</span>);</span><br><span class="line">doWork2(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3. 整体模板化</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">doWork3</span>(<span class="title">T</span> &amp;<span class="title">p</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">typeid</span>(T).name() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">p.show();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Person&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; p(<span class="string">"cc"</span>, <span class="number">14</span>);</span><br><span class="line">doWork3(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-3-类模板的继承"><a href="#2-3-类模板的继承" class="headerlink" title="2.3 类模板的继承"></a>2.3 类模板的继承</h1><p>有一个Base类模板，现在要从Base类模板派生出普通函数Son1和模板函数Son2。需要注意的是，Son1和Son2继承与Base，必须指明Base的T的类型，否则无法分配内存。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基类模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">T a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//派生出普通函数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> :</span><span class="keyword">public</span> Base&lt;<span class="keyword">int</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//派生出模板函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>,<span class="title">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Son1</span> :</span><span class="keyword">public</span> Base&lt;T2&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Son1()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">typeid</span>(T1).name() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">typeid</span>(T2).name() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">T1 b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="2-4-类模板的头文件（分文件编写）"><a href="#2-4-类模板的头文件（分文件编写）" class="headerlink" title="2.4 类模板的头文件（分文件编写）"></a>2.4 类模板的头文件（分文件编写）</h1><p>如果将类模板进行分文件编写，Person.h和Person.cpp分别写声明和实现，会出现问题，由于类模板的成员函数在运行的阶段才去创建，导致只包含Person.h头文件，不会去创建成员函数的实现，所以在链接的过程中，无法解析外部命令。</p><p>解决方案：</p><ol><li>包含Person.cpp文件，<code>#include &quot;Person.cpp&quot;</code>（不推荐）</li><li>类模板不要进行分文件编写，写到一个文件中，类内进行声明，类外进行实现，最后将名字改为Person.hpp，这是约定俗成的。</li></ol><p><strong>Person.hpp</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> PERSON_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PERSON_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">nameType</span>, <span class="title">class</span> <span class="title">ageType</span> = <span class="title">int</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Person(nameType in_name, ageType in_age);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">nameType name;</span><br><span class="line">ageType age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">nameType</span>, <span class="title">class</span> <span class="title">ageType</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">Person</span>&lt;nameType, ageType&gt;:</span>:Person(nameType in_name, ageType in_age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;name = in_name;</span><br><span class="line"><span class="keyword">this</span>-&gt;age = in_age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">nameType</span>, <span class="title">class</span> <span class="title">ageType</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">Person</span>&lt;nameType, ageType&gt;:</span>:show()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"name: "</span> &lt;&lt; <span class="keyword">this</span>-&gt;name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"age: "</span> &lt;&lt; <span class="keyword">this</span>-&gt;age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;谁控制过去，谁就控制未来；谁控制现在，谁就控制过去。——《1984》
    
    </summary>
    
    
    
      <category term="C++" scheme="http://seaworth.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++ day07 多态和头文件</title>
    <link href="http://seaworth.github.io/2019/04/08/CPP-day07/"/>
    <id>http://seaworth.github.io/2019/04/08/CPP-day07/</id>
    <published>2019-04-08T13:19:07.000Z</published>
    <updated>2019-04-09T11:22:09.333Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>人生的意义是从事你真正喜欢的、适合你的并有益于他人的工作。——《财富的自由之路》<a id="more"></a></p></blockquote><h1 id="1-多态"><a href="#1-多态" class="headerlink" title="1 多态"></a>1 多态</h1><p>C++支持编译时多态(<strong>静态多态</strong>)和运行时多态(<strong>动态多态</strong>)，运算符重载和函数重载就是编译时多态，而派生类和虚函数实现运行时多态。</p><p>静态多态和动态多态的区别就是函数地址是早绑定(静态联编)还是晚绑定(动态联编)。如果函数的调用，在编译阶段就可以确定函数的调用地址，并产生代码，就是静态多态。而如果函数的调用地址不能在编译期间确定，而需要在运行时才能决定，这就属于晚绑定。</p><p>真正的开发中，要遵循<strong>开闭原则</strong>：</p><ol><li>对扩展开放，对修改关闭。</li><li>可以利用多态实现——有利于后期的扩展，结构性好，可读性高，但是效率稍微低一点（相比于C语言），因为发生多态的内部结构要复杂一点.</li></ol><p><strong>多态案例-计算器</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; //标准输入输出流</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;<span class="comment">//使用命名空间 std</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Calculate</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//虚函数</span></span><br><span class="line"><span class="comment">//virtual int getResult()&#123; return 0; &#125;</span></span><br><span class="line"><span class="comment">//纯虚函数：如果父类中有了纯虚函数，子类继承父类，就必须实现纯虚函数</span></span><br><span class="line"><span class="comment">//如果父类中有了纯虚函数，这个父类就不能实例化对象</span></span><br><span class="line"><span class="comment">//类中有纯虚函数，这个类叫做抽象类</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">getResult</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setVal</span><span class="params">(<span class="keyword">int</span> in_val1, <span class="keyword">int</span> in_val2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;val1 = in_val1;</span><br><span class="line"><span class="keyword">this</span>-&gt;val2 = in_val2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getVal1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> val1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getVal2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> val2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> val1;</span><br><span class="line"><span class="keyword">int</span> val2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AddCalculate</span>:</span><span class="keyword">public</span> Calculate</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">getResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> getVal1() + getVal2();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//扩展减法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubCalculate</span> :</span><span class="keyword">public</span> Calculate</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">getResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> getVal1() - getVal2();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Calculate *cal;</span><br><span class="line">cal = <span class="keyword">new</span> AddCalculate;</span><br><span class="line">cal-&gt;setVal(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; cal-&gt;getResult() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> cal;</span><br><span class="line">cal = <span class="keyword">new</span> SubCalculate;</span><br><span class="line">cal-&gt;setVal(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">cal-&gt;getResult();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; cal-&gt;getResult() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//函数入口</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">test01();</span><br><span class="line">system(<span class="string">"pause"</span>);<span class="comment">//阻塞功能</span></span><br><span class="line"><span class="keyword">return</span> EXIT_SUCCESS;<span class="comment">//返回正常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="2-编写头文件"><a href="#2-编写头文件" class="headerlink" title="2 编写头文件"></a>2 编写头文件</h1><p>为了确保各个文件中类的定义一致，类通常被定义在头文件中，而且类所在头文件的名字应和类的名字一样。</p><p><strong>预处理</strong></p><p>确保头文件多次包含依然能够安全工作的是预处理器。预处理器是在编译前执行一段程序，可以部分改变我们所写的程序。<code>#include</code>也是一项预处理功能，当预处理器看到<code>#include</code>标记时，就会用指定的头文件的内容代替<code>#include</code>。</p><p>另外一项预处理功能<strong>头文件保护符</strong>，<strong>头文件保护符</strong>依赖于预处理变量，预处理变量分为两种状态：<strong>已定义</strong>和<strong>未定义</strong>。</p><p><code>#define</code>指令：把一个名字设定为预处理变量。</p><p>下面的两个指令分别检查某个指定的预处理变量是否已经定义。<br><code>#ifdef</code>指令：当且仅当变量已定义时为真。<br><code>#ifndef</code>指令：当且仅当变量未定义时为真。<br>一旦检查结果为真，则后续操作直到遇见<code>#endif</code>指令为止。</p><p>使用这些功能就能有效防止多次包含的发生。<br><code>Hero.h</code>文件<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> HERO_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HERO_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hero</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Hero();</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> name;<span class="comment">//名字</span></span><br><span class="line"><span class="keyword">int</span> atk;<span class="comment">//攻击力</span></span><br><span class="line"><span class="keyword">int</span> def;<span class="comment">//防御</span></span><br><span class="line"><span class="keyword">int</span> hp;<span class="comment">//血量</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></p><p>第一次包含Hero.h时，<code>#ifndef</code>的结果为真，预处理器将顺序执行后面的操作，直到遇见<code>#endif</code>。此时，预处理变量HERO_H已经定义。后面如果再次包含Hero.h，则#ifndef的检查结果为假，编译器将忽略<code>#ifndef</code>与<code>#endif</code>之间的部分。</p><p><strong>整个程序的头文件保护符必须唯一，为了避免与程序中的其他实体发生名字冲突，一般把预处理变量的名字全部大写。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;人生的意义是从事你真正喜欢的、适合你的并有益于他人的工作。——《财富的自由之路》
    
    </summary>
    
    
    
      <category term="C++" scheme="http://seaworth.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++ day06 继承</title>
    <link href="http://seaworth.github.io/2019/03/25/CPP-day06/"/>
    <id>http://seaworth.github.io/2019/03/25/CPP-day06/</id>
    <published>2019-03-25T12:54:43.000Z</published>
    <updated>2019-04-14T08:59:27.335Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>美酒的酿造需要年头，美食的烹调需要时间；片刻等待，更多美味，更多享受。<a id="more"></a></p></blockquote><h1 id="1-继承概述"><a href="#1-继承概述" class="headerlink" title="1 继承概述"></a>1 继承概述</h1><p>为什么需要继承？</p><img src="/2019/03/25/CPP-day06/1.png" title="继承"><p>因为有些时候，两个类中大部分的属性和方法相同，只有少量的属性和方法有区别。此时使用<strong>继承</strong>可以复用已有的代码，减少代码的冗余性。</p><p>C++最重要的特征是代码重用，通过继承机制可以利用已有的数据类型来定义新的数据类型，新的类不仅拥有旧类的成员，还拥有新定义的成员。</p><p>派生类定义格式：<br><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Class</span> 派生类名 :  继承方式 基类名</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//派生类新增的数据成员和成员函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>三种继承方式： </p><ul><li>public：公有继承</li><li>protected：保护继承</li><li>private：私有继承</li></ul><p>单继承：指每个派生类只直接继承了一个基类的特征。<br>多继承：指多个基类派生出一个派生类的继承关系，多继承的派生类直接继承了不止一个基类的特征。</p><p>派生类访问控制的权限：<br>派生类继承基类，派生类拥有基类中全部成员变量和成员方法（除了构造和析构之外的成员方法），但是在派生类中，继承的成员并不一定能直接访问，不同的继承方式会导致不同的访问权限。</p><img src="/2019/03/25/CPP-day06/2.png" title="派生类访问控制的权限"><h1 id="3-继承中的构造与析构"><a href="#3-继承中的构造与析构" class="headerlink" title="3 继承中的构造与析构"></a>3 继承中的构造与析构</h1><h2 id="3-1-继承中的对象模型"><a href="#3-1-继承中的对象模型" class="headerlink" title="3.1 继承中的对象模型"></a>3.1 继承中的对象模型</h2><p>在C++编译器的内部可以理解为结构体，子类是由父类成员叠加子类新成员而成。<br><code>test.cpp</code><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; //标准输入输出流</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;<span class="comment">//使用命名空间 std</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="keyword">int</span> b;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子类中会继承父类的私有成员，只是被编译器给隐藏起来了，访问不到私有成员</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son1</span> :</span><span class="keyword">public</span> Father</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> d;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(Son1) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数入口</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">test01();</span><br><span class="line">system(<span class="string">"pause"</span>);<span class="comment">//阻塞功能</span></span><br><span class="line"><span class="keyword">return</span> EXIT_SUCCESS;<span class="comment">//返回正常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果是<code>16</code>。<br>上述代码的保存路径为<code>F:\C++\C++_learning\01 关系运算符重载\06 继承中的对象模型</code>。</p><p>通过<code>VS2013 开发人员命令提示</code>进行查看上述案例的对象模型。<br>在我的电脑上该工具的路径为<code>C:\Program Files (x86)\Microsoft Visual Studio 12.0\Common7\Tools\Shortcuts</code>，如下图所示。</p><img src="/2019/03/25/CPP-day06/VS2013tool.png" title="VS2013开发人员命令提示"><p>打开该命令工具后，切换到该工程目录下，然后打印其对象模型。<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">F:\&gt;<span class="keyword">cd</span> F:\C++\C++_learning\01 （关系运算符重载\06 继承中的对象模型）</span><br><span class="line"><span class="keyword">dir</span> （打印该路径的目录，可以看到<span class="keyword">test</span>.cpp文件）</span><br><span class="line"><span class="keyword">cl</span> /d1 reportSingleClassLayoutSon1 <span class="keyword">test</span>.cpp （输入该命令，打印Son1的对象模型）</span><br></pre></td></tr></table></figure></p><img src="/2019/03/25/CPP-day06/3.png" title="对象模型"><p>可以从红色方框中看出，Son1类从Father基类继承的成员有<code>a</code>，<code>b</code>，<code>c</code>，添加了一个成员<code>d</code>。所以<code>sizeof(Son1)</code>的结果是<code>16</code>（4个int成员变量，每个int是4byte）。</p><h2 id="3-2-继承中的构造和析构"><a href="#3-2-继承中的构造和析构" class="headerlink" title="3.2 继承中的构造和析构"></a>3.2 继承中的构造和析构</h2><p>在C++编译器的内部可以理解为结构体，子类是由父类成员叠加子类新成员而成。</p><ul><li>子类对象在创建时会首先调用父类的构造函数</li><li>父类构造函数执行完毕后，才会调用子类的构造函数</li><li>当父类构造函数有参数时，需要在子类初始化列表(参数列表)中显示调用父类构造函数</li><li>析构函数调用顺序和构造函数相反</li></ul><h1 id="4-继承中的同名处理"><a href="#4-继承中的同名处理" class="headerlink" title="4 继承中的同名处理"></a>4 继承中的同名处理</h1><ul><li>当子类成员和父类成员同名时，子类依然继承父类的同名成员。</li><li>如果子类成员和父类成员同名时，子类访问其成员时，默认访问子类的成员（就近原则）。</li><li>如果要访问父类的同名成员时，需要通过作用域::进行同名成员区分。</li></ul><h1 id="5-继承中的静态成员"><a href="#5-继承中的静态成员" class="headerlink" title="5 继承中的静态成员"></a>5 继承中的静态成员</h1><p>父类中的静态成员属性，子类可以继承下来。<br>父类中的静态成员函数，子类对象可以通过作用域::访问。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; //标准输入输出流</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;<span class="comment">//使用命名空间 std</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> a;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"base void func()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"base void func(int val)"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> Base::a = <span class="number">10</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> :</span><span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> a;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"son void func()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> Son::a = <span class="number">20</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//静态成员属性，子类可以继承下来</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; Son::a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; Base::a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//访问父类的同名函数</span></span><br><span class="line">Son::func();</span><br><span class="line">Son::Base::func(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数入口</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">test01();</span><br><span class="line">system(<span class="string">"pause"</span>);<span class="comment">//阻塞功能</span></span><br><span class="line"><span class="keyword">return</span> EXIT_SUCCESS;<span class="comment">//返回正常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果：<br><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">20</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line">son void <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line">base void <span class="function"><span class="keyword">func</span><span class="params">(int val)</span></span></span><br><span class="line">请按任意键继续. . .</span><br></pre></td></tr></table></figure></p><h1 id="6-多继承"><a href="#6-多继承" class="headerlink" title="6 多继承"></a>6 多继承</h1><blockquote><p>可以从一个类继承，也能同时从多个类继承，这就是多继承。但是由于多继承是非常受争议的，从多个类继承可能会导致函数、变量等同名导致较多的歧义。</p></blockquote><img src="/2019/03/25/CPP-day06/4.png" title="多继承"><p>带来的问题：<br>如果两个基类中有同名的函数或者变量，那么通过派生类对象去访问这个函数或变量时就不能明确到底调用从基类1继承的版本还是从基类2继承的版本？<br>解决方法：<br>显示指定调用那个基类的版本。</p><p><strong>菱形继承</strong></p><img src="/2019/03/25/CPP-day06/5.png" title="菱形继承"><p>这种继承所带来的问题：</p><ol><li>B1继承了A的数据和函数，B2同样继承了A的数据和函数，当C调用函数或者数据时，就会产生二义性。</li><li>C继承自A的函数和数据继承了两份，这份数据我们只需要一份就可以。</li></ol><p>对于这种<strong>菱形继承</strong>所带来的两个问题，C++为我们提供了一种方式：<strong>采用虚基类</strong>。</p><img src="/2019/03/25/CPP-day06/6.png" title="菱形继承"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; //标准输入输出流</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;<span class="comment">//使用命名空间 std</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sheep</span>:</span><span class="keyword">virtual</span> <span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tuo</span> :</span><span class="keyword">virtual</span> <span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SheepTuo</span> :</span><span class="keyword">public</span> Sheep, <span class="keyword">public</span> Tuo</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//解决菱形问题，用虚继承</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">SheepTuo s1;</span><br><span class="line">s1.Sheep::age = <span class="number">10</span>;</span><br><span class="line">s1.Tuo::age = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s1.Sheep::age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s1.Tuo::age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s1.age &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//虚继承解决了二义性，只有一份age</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"-----------以下为虚继承的工作原理-----------"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">SheepTuo s2;</span><br><span class="line">s2.age = <span class="number">666</span>;</span><br><span class="line"><span class="comment">//Sheep的偏移量</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *((<span class="keyword">int</span>*)(*(<span class="keyword">int</span>*)(&amp;s2)) + <span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//Tuo的偏移量</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *((<span class="keyword">int</span>*)(*((<span class="keyword">int</span>*)&amp;s2+<span class="number">1</span>)) + <span class="number">1</span>)&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//输出age</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;((Animal*)((<span class="keyword">char</span>*)&amp;s2 + <span class="number">8</span>))-&gt;age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//函数入口</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">test01();</span><br><span class="line">system(<span class="string">"pause"</span>);<span class="comment">//阻塞功能</span></span><br><span class="line"><span class="keyword">return</span> EXIT_SUCCESS;<span class="comment">//返回正常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><img src="/2019/03/25/CPP-day06/7.png" title="结果1"><p>从结果中看出虚继承只有一份age，输出3个20。<br>我们可以通过前面介绍的方法，在<code>VS2013 开发人员命令提示</code>上进行查看的SheepTuo对象模型，如下图：</p><img src="/2019/03/25/CPP-day06/8.png" title="结果2"><p>可以看出虚继承，只存在一份<strong>age</strong>。<br>1.Animal菱形最顶层的类，内存布局图没有发生改变。<br>2.Sheep和Tuo通过虚继承的方式派生自Animal，这两个对象的布局图中可以看出编译器为我们的对象中增加了一个<strong>vbptr</strong> (virtual base pointer)，<strong>vbptr</strong>指向了一张表，这张表保存了当前的虚指针相对于虚基类的首地址的偏移量。<br>3.SheepTuo派生于Sheep和Tuo，继承了两个基类的vbptr指针，并调整了vbptr与虚基类的首地址的偏移量。</p><blockquote><p>工程开发中真正意义上的多继承是几乎不被使用，因为多重继承带来的代码复杂性远多于其带来的便利，多重继承对代码维护性上的影响是灾难性的，在设计方法上，任何多继承都可以用单继承代替。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;美酒的酿造需要年头，美食的烹调需要时间；片刻等待，更多美味，更多享受。
    
    </summary>
    
    
    
      <category term="C++" scheme="http://seaworth.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++ day05 运算符重载</title>
    <link href="http://seaworth.github.io/2019/03/08/CPP-day05/"/>
    <id>http://seaworth.github.io/2019/03/08/CPP-day05/</id>
    <published>2019-03-08T13:10:46.000Z</published>
    <updated>2019-04-14T08:44:27.936Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>人生最后的高度可能都是一样的，就是一张病床的高度。人生是如此充满了不确定性，而过去的爱恨情仇与人的生命相比，是那么不值得一提。——《颠覆者》<a id="more"></a></p><p>运算符重载，就是对已有的<strong>运算符</strong>重新进行定义，赋予其另一种功能，以适应不同的数据类型。在C++中，可以定义一个处理类的新运算符。这种定义很像一个普通的函数定义，只是函数的名字由关键字operator及其紧跟的运算符组成。它像任何其他函数一样，当编译器遇到适当的模式时，就会调用这个函数。</p></blockquote><p><strong>注：不要滥用运算符重载，只有在能够使类的代码更容易写，容易读，才有理由重载运算符。对于内置的数据类型的所有运算符是不可能改变的。</strong></p><h1 id="1-加号运算符重载"><a href="#1-加号运算符重载" class="headerlink" title="1 加号运算符重载"></a>1 加号运算符重载</h1><p>两种实现方法：</p><ol><li>类的成员函数实现+重载</li><li>全局函数实现+重载</li></ol><blockquote><p>需求：</p><ol><li>定义一个Person类，含有两个成员变量a和b（public）</li><li>分别用成员函数和全局函数实现+运算符重载</li></ol></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; //标准输入输出流</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;<span class="comment">//使用命名空间 std</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Person()&#123;&#125;</span><br><span class="line">Person(<span class="keyword">int</span> in_a, <span class="keyword">int</span> in_b) :a(in_a), b(in_b)&#123;&#125;</span><br><span class="line">~Person()&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1：打开成员函数重载加号；0：关闭</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">Person <span class="keyword">operator</span>+ (<span class="keyword">const</span> Person p1)</span><br><span class="line">&#123;</span><br><span class="line">Person temp;</span><br><span class="line">temp.a = <span class="keyword">this</span>-&gt;a + p1.a;</span><br><span class="line">temp.b = <span class="keyword">this</span>-&gt;b + p1.b;</span><br><span class="line"><span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1：打开全局函数，实现加法重载；0：关闭</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 1</span></span><br><span class="line">Person <span class="keyword">operator</span>+ (<span class="keyword">const</span> Person p1, <span class="keyword">const</span> Person p2)</span><br><span class="line">&#123;</span><br><span class="line">Person temp;</span><br><span class="line">temp.a = p2.a + p1.a;</span><br><span class="line">temp.b = p2.b + p1.b;</span><br><span class="line"><span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">1</span>,<span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">2</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line">Person p3=p1+p2;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"p3的a:"</span> &lt;&lt; p3.a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"p3的b:"</span> &lt;&lt; p3.b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//函数入口</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">test01();</span><br><span class="line">system(<span class="string">"pause"</span>);<span class="comment">//阻塞功能</span></span><br><span class="line"><span class="keyword">return</span> EXIT_SUCCESS;<span class="comment">//返回正常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-左移运算符重载"><a href="#2-左移运算符重载" class="headerlink" title="2 左移运算符重载"></a>2 左移运算符重载</h1><blockquote><p>需求：</p><ol><li>定义一个Person类，含有两个成员变量a和b（public）</li><li>用全局函数对&lt;&lt;运算符进行重载</li><li>能够实现链式输出，如<code>cout&lt;&lt;p1&lt;&lt;p2&lt;&lt;endl;</code></li></ol></blockquote><p><strong>不能用类的成员函数对&lt;&lt;进行重载，因为如果是Person的成员函数，那么调用就是Person &lt;&lt; 不满足要求</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; //标准输入输出流</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;<span class="comment">//使用命名空间 std</span></span><br><span class="line"><span class="comment">//&lt;&lt;运算符重载</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1. 用全局函数进行&lt;&lt;重载</span></span><br><span class="line"><span class="comment">2. 参数是ostream&amp; cout 和 Person p1</span></span><br><span class="line"><span class="comment">3. Person类中对重载函数进行友元函数声明，使其能够访问私有的成员变量</span></span><br><span class="line"><span class="comment">4. 要进行链式输出，需要返回哦stream&amp;，从而保证返回值是cout</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span> &lt;&lt; (ostream&amp; <span class="built_in">cout</span>, Person p1);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Person()&#123;&#125;</span><br><span class="line">Person(<span class="keyword">int</span> in_a, <span class="keyword">int</span> in_b) :a(in_a), b(in_b)&#123;&#125;</span><br><span class="line">~Person()&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不能用类的成员函数对&lt;&lt;进行重载，因为如果是Person的成员函数，那么调用就是Person &lt;&lt; 不满足要求</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ostream&amp; <span class="keyword">operator</span> &lt;&lt; (ostream&amp; <span class="built_in">cout</span>, Person p1)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"a = "</span> &lt;&lt; p1.a &lt;&lt; <span class="string">" b = "</span> &lt;&lt; p1.b &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">cout</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">1</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">2</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; p1 &lt;&lt; p2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//函数入口</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">test01();</span><br><span class="line">system(<span class="string">"pause"</span>);<span class="comment">//阻塞功能</span></span><br><span class="line"><span class="keyword">return</span> EXIT_SUCCESS;<span class="comment">//返回正常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="3-递增递减运算符重载"><a href="#3-递增递减运算符重载" class="headerlink" title="3 递增递减运算符重载"></a>3 递增递减运算符重载</h1><p><strong>前置++</strong>：如++a，先++，再返回<br><strong>后置++</strong>：如a++，先返回，后++</p><blockquote><p>重载++运算符时，需要重载两个函数（前置++和后置++）。重载–运算符同理可得。<br>调用代码时候，要优先使用前缀形式，除非确实需要后缀形式返回的原值，前缀和后缀形式语义上是等价的，输入工作量也相当，只是效率经常会略高一些，由于前缀形式少创建了一个临时对象。<br>需求：</p><ol><li>定义一个Person类，含有一个成员变量age（private）</li><li>重载++运算符，能够进行age加一</li><li>重载–运算符，能够进行age减一</li><li>重载&lt;&lt;运算符，能够打印年龄 </li></ol></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; //标准输入输出流</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;<span class="comment">//使用命名空间 std</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt; (ostream&amp; <span class="built_in">cout</span>, Person p1);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Person()&#123;&#125;</span><br><span class="line">Person(<span class="keyword">int</span> in_age) :age(in_age)&#123;&#125;</span><br><span class="line">~Person()&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重载前置++，先++，再返回</span></span><br><span class="line">Person&amp; <span class="keyword">operator</span>++ ()</span><br><span class="line">&#123;</span><br><span class="line">++(<span class="keyword">this</span>-&gt;age);<span class="comment">//前置++，效率稍高</span></span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重载后置++，多一个占位参数进行区分</span></span><br><span class="line"><span class="comment">//先返回，再++</span></span><br><span class="line"><span class="comment">//后置++调用的时候，会多拷贝一次数据，比前置++的效率要差一些。</span></span><br><span class="line">Person <span class="keyword">operator</span>++ (<span class="keyword">int</span>)</span><br><span class="line">&#123;</span><br><span class="line">Person temp = *<span class="keyword">this</span>;<span class="comment">//先用一个临时的值保存住要返回的值</span></span><br><span class="line">++(<span class="keyword">this</span>-&gt;age);</span><br><span class="line"><span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重载前置--</span></span><br><span class="line">Person&amp; <span class="keyword">operator</span>-- ()</span><br><span class="line">&#123;</span><br><span class="line">--(<span class="keyword">this</span>-&gt;age);</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重置后置--</span></span><br><span class="line">Person <span class="keyword">operator</span>-- (<span class="keyword">int</span>)</span><br><span class="line">&#123;</span><br><span class="line">Person temp = *<span class="keyword">this</span>;</span><br><span class="line">--(<span class="keyword">this</span>-&gt;age);</span><br><span class="line"><span class="keyword">return</span> temp;<span class="comment">//返回值只能用值传递，以为返回的一个临时的变量，如果返回引用，临时变量会被释放，从而引发错误</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重载&lt;&lt;</span></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt; (ostream&amp; <span class="built_in">cout</span>, Person p1)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; p1.age;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">cout</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ++p1 &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//1</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; p1++ &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//1</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; p1 &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//2</span></span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; --p2 &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//9</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; p2-- &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//9</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; p2 &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//8</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//函数入口</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">test01();</span><br><span class="line">system(<span class="string">"pause"</span>);<span class="comment">//阻塞功能</span></span><br><span class="line"><span class="keyword">return</span> EXIT_SUCCESS;<span class="comment">//返回正常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="4-指针运算符重载"><a href="#4-指针运算符重载" class="headerlink" title="4 指针运算符重载"></a>4 指针运算符重载</h1><blockquote><p>实现一个智能指针（smartPointer）的类，用来管理Person类。如果在堆区new了一个Person类型的内存，忘记了释放就会导致内存泄漏，而smartPointer就是用来释放内存。<br>实现步骤：</p><ol><li>定义一个Person类，含有一个成员变量age（private）</li><li>定义一个smartPointer类，含有一个成员变量Person* p，在析构函数中对p进行释放</li><li>对smartPointer类，重载-&gt;和*运算符</li></ol></blockquote><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#include &lt;iostream&gt; //标准输入输出流</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="title">std</span>;<span class="comment">//使用命名空间 std</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Person()&#123;&#125;</span><br><span class="line">Person(<span class="keyword">int</span> in_age) :age(in_age)&#123;&#125;</span><br><span class="line">~Person()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">"调用Person的析构函数"</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showAge</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">"年龄： "</span> &lt;&lt; age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//智能指针</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">smartPointer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">smartPointer(Person * p1) :p(p1)&#123;&#125;</span><br><span class="line">~smartPointer()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">"调用smartPointer的指针"</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;p != NULL)<span class="comment">//检查p中是否开辟了内存，如果不为空，则释放</span></span><br><span class="line">&#123;</span><br><span class="line">delete <span class="keyword">this</span>-&gt;p;</span><br><span class="line"><span class="keyword">this</span>-&gt;p = NULL;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重载-&gt;</span></span><br><span class="line">Person* <span class="keyword">operator</span>-&gt; ()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>-&gt;p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重载*</span></span><br><span class="line">Person&amp; <span class="keyword">operator</span>* ()<span class="comment">//注意返回的是引用</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> *(<span class="keyword">this</span>-&gt;p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Person * p;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//Person* p1 = new Person(10);</span></span><br><span class="line"><span class="comment">//如果忘记释放，那么就会造成内存泄漏</span></span><br><span class="line"></span><br><span class="line"><span class="function">smartPointer <span class="title">sp</span>(<span class="params">new Person(<span class="number">10</span></span>))</span>;<span class="comment">//sp开辟到了栈上，自动释放</span></span><br><span class="line">sp-&gt;showAge();<span class="comment">//sp-&gt;-&gt;showAge()，编译器做了优化</span></span><br><span class="line">(*sp).showAge();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//函数入口</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">test01();</span><br><span class="line">system(<span class="string">"pause"</span>);<span class="comment">//阻塞功能</span></span><br><span class="line"><span class="keyword">return</span> EXIT_SUCCESS;<span class="comment">//返回正常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="5-赋值运算符重载"><a href="#5-赋值运算符重载" class="headerlink" title="5 赋值运算符重载"></a>5 赋值运算符重载</h1><p><strong>常见错误，当准备给两个相同对象赋值时，应该首先检查一下这个对象是否对自身赋值了。</strong><br><strong><code>为什么要检查自我赋值？</code></strong></p><p>1.<strong>为了效率。自己给自己赋值完全没有意义，浪费开销，应该避免。如果是自我赋值，应该直接返回<code>* this</code></strong>。</p><p>2.<strong>为了正确性。因为指针间的赋值（假设p2=p1），在复制前，需要将p2所指向的空间杀掉delete，然后重新为p2分配空间，再将<code>p1所指的内容</code>拷贝到<code>p2所指的空间</code>，如果是自我赋值，p1和p2是同一指针，在赋值操作前，杀掉p2所指的空间（即杀掉p1所指的空间），要赋值的数据（p1指向的内容）已被杀掉，程序报错。</strong></p><blockquote><p>一个类默认创建四个函数：</p></blockquote><ol><li>默认构造函数</li><li>析构函数</li><li>拷贝构造函数</li><li>operator=重载函数（只进行简单的值传递）</li></ol><p><strong>当类中含有指针时，必须对=进行重载，从而避免浅拷贝</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; //标准输入输出流</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;<span class="comment">//使用命名空间 std</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//一个类默认创建四个函数：默认构造函数，析构函数，拷贝构造函数，operator=重载函数（只进行简单的值传递）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Person(<span class="keyword">int</span> in_age,<span class="keyword">int</span> in_id) :age(in_age),id(in_id)&#123;&#125;</span><br><span class="line">~Person()&#123;&#125;</span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">int</span> id;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1. =号容易混淆的地方</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>,<span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">20</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">Person p3 = p1;<span class="comment">//调用拷贝构造，</span></span><br><span class="line"><span class="comment">//如果一个对象还没有被创建，则必须初始化，即调用构造函数。</span></span><br><span class="line"><span class="comment">//p3还没有初始化，所以会调用构造函数</span></span><br><span class="line"><span class="comment">//p3是从p1创建而来，所以需要调用拷贝构造函数</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt;<span class="string">"p3: age = "</span>&lt;&lt; p3.age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt;<span class="string">"p3: id  = "</span>&lt;&lt; p3.id  &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">p2 = p1;<span class="comment">//调用operator=函数</span></span><br><span class="line"><span class="comment">//由于p2已经创建了，不用再调用构造函数了，只需调用重载的=运算符函数</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"p2: age = "</span> &lt;&lt; p2.age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"p2: id  = "</span> &lt;&lt; p2.id  &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 类中含有指针</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Person2(<span class="keyword">const</span> <span class="keyword">char</span>* in_name)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;name = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(in_name) + <span class="number">1</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;name, in_name);</span><br><span class="line">&#125;</span><br><span class="line">Person2&amp; <span class="keyword">operator</span>= (<span class="keyword">const</span> Person2&amp; p)<span class="comment">//传入的是引用，函数返回值也是引用，能实现连续=</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//检查是否是自我赋值</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span> == &amp;p)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果判断原来已经堆区有内容，先释放</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;name != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span>[] <span class="keyword">this</span>-&gt;name;</span><br><span class="line"><span class="keyword">this</span>-&gt;name = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>-&gt;name = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(p.name) + <span class="number">1</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;name,p.name);</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~Person2()</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//类的成员中有指针，需要释放</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;name != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span>[] <span class="keyword">this</span>-&gt;name;</span><br><span class="line"><span class="keyword">this</span>-&gt;name = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span>* name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">Person2 <span class="title">p1</span><span class="params">(<span class="string">"老王"</span>)</span></span>;</span><br><span class="line"><span class="function">Person2 <span class="title">p2</span><span class="params">(<span class="string">"大王"</span>)</span></span>;</span><br><span class="line"><span class="function">Person2 <span class="title">p3</span><span class="params">(<span class="string">"小王"</span>)</span></span>;</span><br><span class="line">p2 = p1;<span class="comment">//编译器默认的=重载是简单的值复制，如果类中含有指针，就会产生浅拷贝问题，释放指针的时候，就会造成两次释放，所以必须重载=</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; p2.name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">p3 = p2 = p1;<span class="comment">//检查重载=</span></span><br><span class="line">p3 = p3;<span class="comment">//检查自我赋值</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; p3.name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//函数入口</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">test01();</span><br><span class="line">test02();</span><br><span class="line">system(<span class="string">"pause"</span>);<span class="comment">//阻塞功能</span></span><br><span class="line"><span class="keyword">return</span> EXIT_SUCCESS;<span class="comment">//返回正常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;人生最后的高度可能都是一样的，就是一张病床的高度。人生是如此充满了不确定性，而过去的爱恨情仇与人的生命相比，是那么不值得一提。——《颠覆者》
    
    </summary>
    
    
    
      <category term="C++" scheme="http://seaworth.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++ day04</title>
    <link href="http://seaworth.github.io/2019/03/04/CPP-day04/"/>
    <id>http://seaworth.github.io/2019/03/04/CPP-day04/</id>
    <published>2019-03-04T12:12:37.000Z</published>
    <updated>2019-04-14T08:47:14.025Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>真正的光明绝不是没有黑暗的时间，只是永远不被黑暗掩蔽罢了。真正的英雄绝不是没有卑下的情操，只是永不被卑下的情操所屈服罢了。——《颠覆者》<a id="more"></a></p></blockquote><h1 id="1-静态成员"><a href="#1-静态成员" class="headerlink" title="1 静态成员"></a>1 静态成员</h1><p>在类定义中，成员包括<strong>成员变量</strong>和<strong>成员函数</strong>，这些成员可以用关键字<strong><code>static</code></strong>声明为静态的，称为<strong>静态成员</strong>。<br>不管这个类创建了多少个对象，<strong>静态成员只有一个拷贝</strong>，这个拷贝被所有属于这个类的对象<strong>共享</strong>。</p><h2 id="1-1-静态成员变量"><a href="#1-1-静态成员变量" class="headerlink" title="1.1 静态成员变量"></a>1.1 静态成员变量</h2><p>类中的成员声明为<strong>static</strong>，这种成员称为<strong>静态成员变量</strong>。与一般的数据成员不同，无论建立多少个对象，都只有一个静态数据的拷贝。<strong>静态成员变量属于类，所有对象共享</strong>。</p><blockquote><p>静态成员变量在编译的阶段就分配内存，对象还没有建立时，就分配了空间。</p><ul><li>静态成员变量必须在<strong>类中声明</strong>，在<strong>类外定义</strong>。</li><li>静态数据成员不属于某个对象，在为对象分配空间中不包括静态成员所占空间。</li><li>静态数据成员可以通过类名或者对象名来引用。</li></ul></blockquote><h2 id="1-2-静态成员函数"><a href="#1-2-静态成员函数" class="headerlink" title="1.2 静态成员函数"></a>1.2 静态成员函数</h2><p>在类定义中，前面有static说明的成员函数称为<strong>静态成员函数</strong>。静态成员函数使用方式和静态变量一样，同样在对象没有创建前，即可通过类名调用。静态成员函数主要为了<strong>访问静态变量</strong>，但是，<strong>不能访问普通成员变量</strong>。<br>静态成员函数的意义，不在于信息共享，数据沟通，而在于管理静态数据成员，完成对静态数据成员的封装。</p><ul><li>静态成员函数只能访问静态变量</li><li>静态成员函数也是有权限的private，public</li><li>普通成员函数既可以访问静态成员变量，也可以访问非静态成员变量</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; //标准输入输出流</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;<span class="comment">//使用命名空间 std</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//加入static就是静态成员变量，会共享数据，在类内声明，类外初始化</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line"><span class="comment">//静态成员函数，不可以访问普通的成员变量，可以访问静态的成员函数</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"static void func()调用"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//普通的成员函数，可以访问普通成员变量，也可以访问静态成员变量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myFunc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">age = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> other;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"static void func1()调用"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类外对静态成员进行初始化</span></span><br><span class="line"><span class="keyword">int</span> Person::age = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> Person::other = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//1 通过对象访问属性</span></span><br><span class="line">Person p1;</span><br><span class="line">p1.age = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">Person p2;</span><br><span class="line">p2.age = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"p1.age = "</span> &lt;&lt; p1.age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"p2.age = "</span> &lt;&lt; p2.age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2 通过类名访问属性</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"通过类名访问属性age："</span> &lt;&lt; Person::age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3 私有权限在类外无法访问</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; "other = " &lt;&lt; Person::other &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">p1.func();</span><br><span class="line">p2.func();</span><br><span class="line">Person::func();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数入口</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">test01();</span><br><span class="line">system(<span class="string">"pause"</span>);<span class="comment">//阻塞功能</span></span><br><span class="line"><span class="keyword">return</span> EXIT_SUCCESS;<span class="comment">//返回正常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-单例模式"><a href="#2-单例模式" class="headerlink" title="2 单例模式"></a>2 单例模式</h1><p>单例模式是一种常用的软件设计模式。在它的核心结构中只包含一个被称为单例的特殊类。通过单例模式可以保证系统中一个类只有一个实例而且该实例易于外界访问，从而方便对实例个数的控制并节约系统资源。如果希望在系统中某个类的对象只能存在一个，单例模式是最好的解决方案。</p><blockquote><p>Singleton（单例）：在单例类的内部实现只生成一个实例，同时它提供一个静态的getInstance()工厂方法，让客户可以访问它的唯一实例；为了防止在外部对其实例化，将其默认构造函数和拷贝构造函数设计为私有；在单例类内部定义了一个Singleton类型的静态对象，作为外部共享的唯一实例。</p><p>用单例模式，模拟公司员工使用打印机场景，打印机可以打印员工要输出的内容，并且可以累积打印机使用次数。</p><ol><li>默认构造函数私有化</li><li>拷贝构造函数私有化</li><li>内部维护一个对象指针</li><li>私有化唯一指针</li><li>对外提供getInstance方法来访问这个指针</li></ol></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Printer</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//静态函数</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> Printer* <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> singlePrinter;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printText</span><span class="params">(<span class="built_in">string</span> text)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; text &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">count++;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"目前打印次数："</span> &lt;&lt; count &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Printer()&#123; count = <span class="number">0</span>; &#125;</span><br><span class="line">Printer(<span class="keyword">const</span> Printer&amp; p1)&#123;&#125;</span><br><span class="line"><span class="keyword">static</span> Printer* singlePrinter;</span><br><span class="line"></span><br><span class="line"><span class="comment">//记录打印次数</span></span><br><span class="line"><span class="keyword">int</span> count;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Printer* Printer::singlePrinter=<span class="keyword">new</span> Printer;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//拿到打印机</span></span><br><span class="line">Printer* Printer = Printer::getInstance();</span><br><span class="line">Printer-&gt;printText(<span class="string">"hello 单例模式"</span>);</span><br><span class="line">Printer-&gt;printText(<span class="string">"hello 单例模式"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-成员变量和成员函数的存储"><a href="#3-成员变量和成员函数的存储" class="headerlink" title="3 成员变量和成员函数的存储"></a>3 成员变量和成员函数的存储</h1><ul><li>C++中的<strong>非静态数据成员</strong>直接内含在类对象中，就像c struct一样。</li><li>静态成员变量不属于对象</li><li>静态成员函数和非静态成员函数都不属于对象</li></ul><p>结论：C++类对象中的变量和函数是分开存储，只有非静态成员变量属于对象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> age;<span class="comment">//非静态成员变量，属于对象</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;&#125;<span class="comment">//非静态成员函数，不属于对象</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> id;<span class="comment">//静态成员变量，不属于对象</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span></span>&#123;&#125;<span class="comment">//静态成员函数，不属于对象</span></span><br><span class="line"><span class="comment">//结论：只有非静态成员变量，属于对象</span></span><br><span class="line"><span class="keyword">double</span> a;<span class="comment">//4+8=12,字节对齐，16</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//空类的大小为1，因为每个实例的对象都有一个独一无二的地址，char维护这个地址</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"sizeof(Person): "</span> &lt;&lt;<span class="keyword">sizeof</span>(Person)&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="4-this指针"><a href="#4-this指针" class="headerlink" title="4 this指针"></a>4 this指针</h1><h2 id="4-1-this指针的工作原理"><a href="#4-1-this指针的工作原理" class="headerlink" title="4.1 this指针的工作原理"></a>4.1 this指针的工作原理</h2><p>C++的数据和操作也是分开存储，也就是说多个同类型的对象会共用一块代码，这一块代码是如何区分哪个对象调用自己的呢？<br><img src="/2019/03/04/CPP-day04/1.png" title="工作原理"> </p><p>C++通过提供特殊的对象指针，<strong>this指针</strong>，解决上述问题。this指针指向被调用的成员函数所属的对象。</p><h2 id="4-2-this指针的使用"><a href="#4-2-this指针的使用" class="headerlink" title="4.2 this指针的使用"></a>4.2 this指针的使用</h2><ul><li>当形参和成员变量同名时，可用this指针来区分</li><li>在类的非静态成员函数中返回对象本身，可使用<code>return *this</code></li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//1. 当形参名和成员变量名一样时，this指针可用来区分</span></span><br><span class="line">Person(int age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 返回对象本身的引用</span></span><br><span class="line">Person&amp; addAge(Person &amp;p1)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;age += p1.age;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;<span class="comment">//*this指向对象本体</span></span><br><span class="line">&#125;</span><br><span class="line">int age;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="4-3-const修饰成员函数"><a href="#4-3-const修饰成员函数" class="headerlink" title="4.3 const修饰成员函数"></a>4.3 const修饰成员函数</h2><ul><li>用const修饰的成员函数时，const修饰this指针指向的内存区域，成员函数体内<strong>不可以</strong>修改本类中的任何<strong>普通成员变量</strong></li><li>当成员变量类型符前用<strong><code>mutable</code></strong>修饰时例外</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Person()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_b = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showInfo</span><span class="params">()</span> <span class="keyword">const</span><span class="comment">//常函数，不允许修改指针指向的值</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//this-&gt;m_a = 11;</span></span><br><span class="line"><span class="keyword">this</span>-&gt;m_b = <span class="number">11</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"m_a = "</span> &lt;&lt; m_a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"m_b = "</span> &lt;&lt; m_b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//m_a = 22;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//private:</span></span><br><span class="line"><span class="keyword">int</span> m_a;</span><br><span class="line"><span class="keyword">mutable</span> <span class="keyword">int</span> m_b;<span class="comment">//就算是常函数，也要执意修改</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="4-4-const修饰成员对象"><a href="#4-4-const修饰成员对象" class="headerlink" title="4.4 const修饰成员对象"></a>4.4 const修饰成员对象</h2><ul><li>常对象只能调用<strong>const的成员函数</strong></li><li>常对象可访问const或非const数据成员，不能修改，除非成员用mutable修饰</li></ul><h1 id="5-友元"><a href="#5-友元" class="headerlink" title="5 友元"></a>5 友元</h1><p>类的主要特点之一是<strong>数据隐藏</strong>，即类的私有成员无法在类的外部(作用域之外)访问。但是，有时候需要在类的外部访问类的私有成员，怎么办？</p><blockquote><p>解决方法:<br>使用友元函数，友元函数是一种特权函数，C++允许这个特权函数访问私有成员。<br>举个例子：家里有客厅、卧室，客厅是Public的，所有的客人都可以进去，但是你的卧室是private的，只有你能进去，但是，你也可以允许你的好朋友进去。<br>程序员可以把一个全局函数、某个类中的成员函数、甚至整个类声明为友元。</p><ol><li>全局函数作友元</li><li>类作友元</li><li>类的成员函数作友元</li></ol></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Building</span>;</span></span><br><span class="line"><span class="comment">//友元类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyFriend</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//友元成员函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LookAtBedRoom</span><span class="params">(Building&amp; building)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PlayInBedRoom</span><span class="params">(Building&amp; building)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Building</span>&#123;</span></span><br><span class="line"><span class="comment">//全局函数做友元函数</span></span><br><span class="line"><span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">CleanBedRoom</span><span class="params">(Building&amp; building)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line"><span class="comment">//成员函数做友元函数</span></span><br><span class="line"><span class="keyword">friend</span> <span class="keyword">void</span> MyFriend::LookAtBedRoom(Building&amp; building);</span><br><span class="line"><span class="keyword">friend</span> <span class="keyword">void</span> MyFriend::PlayInBedRoom(Building&amp; building);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="comment">//友元类</span></span><br><span class="line"><span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">MyFriend</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Building();</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">string</span> mSittingRoom;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">string</span> mBedroom;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> MyFriend::LookAtBedRoom(Building&amp; building)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"我的朋友参观"</span> &lt;&lt; building.mBedroom &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> MyFriend::PlayInBedRoom(Building&amp; building)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"我的朋友玩耍在"</span> &lt;&lt; building.mBedroom &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//友元全局函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CleanBedRoom</span><span class="params">(Building&amp; building)</span></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"友元全局函数访问"</span> &lt;&lt; building.mBedroom &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Building::Building()&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;mSittingRoom = <span class="string">"客厅"</span>;</span><br><span class="line"><span class="keyword">this</span>-&gt;mBedroom = <span class="string">"卧室"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">Building building;</span><br><span class="line">MyFriend myfriend;</span><br><span class="line"></span><br><span class="line">CleanBedRoom(building);</span><br><span class="line">myfriend.LookAtBedRoom(building);</span><br><span class="line">myfriend.PlayInBedRoom(building);</span><br><span class="line"></span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>特别注意</strong><br>在用VS2010，新建的项目名称为<code>10 成员函数做友元函数</code>，这个例子中，编译器会提示如下错误</p><img src="/2019/03/04/CPP-day04/2.png" title="警告"><p>但点击<code>生成</code>-&gt;重新生成 <code>10 成员函数做友元函数</code>，又成功，没有失败，但错误列表中仍提示错误。</p><img src="/2019/03/04/CPP-day04/3.png" title="输出"><p>此时估计是编译器犯糊涂了，语法和程序都没有问题。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;真正的光明绝不是没有黑暗的时间，只是永远不被黑暗掩蔽罢了。真正的英雄绝不是没有卑下的情操，只是永不被卑下的情操所屈服罢了。——《颠覆者》
    
    </summary>
    
    
    
      <category term="C++" scheme="http://seaworth.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++ day03</title>
    <link href="http://seaworth.github.io/2019/02/27/CPP-day03/"/>
    <id>http://seaworth.github.io/2019/02/27/CPP-day03/</id>
    <published>2019-02-27T14:13:17.000Z</published>
    <updated>2019-04-14T08:55:50.522Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>那些不能杀死我的，使我更强！<br>What does not kill me, makes me stronger.<br>——尼采（哲学家）<a id="more"></a></p></blockquote><h1 id="1-面向对象设计案例—点和圆的关系"><a href="#1-面向对象设计案例—点和圆的关系" class="headerlink" title="1 面向对象设计案例—点和圆的关系"></a>1 面向对象设计案例—点和圆的关系</h1><ul><li>需求分析：</li></ul><p>设计一个圆形类Circle，和一个点类Point，计算点和圆的关系。<br>假如圆心坐标为x0, y0, 半径为r，点的坐标为x1, y1：</p><ol><li>点在圆上：(x1 - x0)*(x1 - x0) + (y1 - y0)*(y1 - y0) == r*r</li><li>点在圆内：(x1 - x0)*(x1 - x0) + (y1 - y0)*(y1 - y0) &lt; r*r</li><li>点在圆外：(x1 - x0)*(x1 - x0) + (y1 - y0)*(y1 - y0) &gt; r*r</li></ol><ul><li>采用<strong>分文件编写</strong>的方式</li><li>编程环境：VS2010</li></ul><h1 id="2-代码实现"><a href="#2-代码实现" class="headerlink" title="2 代码实现"></a>2 代码实现</h1><h2 id="2-1-新建一个空项目"><a href="#2-1-新建一个空项目" class="headerlink" title="2.1 新建一个空项目"></a>2.1 新建一个空项目</h2><ol><li>添加<code>02 面向对象设计案例—点和圆的关系.cpp</code></li><li>添加<code>circle.cpp</code></li><li>添加<code>point.cpp</code></li><li>添加头文件<code>circle.h</code></li><li>添加头文件<code>point.h</code></li></ol><p>建立好项目后如图所示：</p><img src="/2019/02/27/CPP-day03/1.png" title="项目"> <h2 id="2-2-相关代码"><a href="#2-2-相关代码" class="headerlink" title="2.2 相关代码"></a>2.2 相关代码</h2><p>头文件<code>point.h</code><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once<span class="comment">//避免头文件多次编译</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//点类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//设置x,y</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setX</span><span class="params">(<span class="keyword">int</span> in_x)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setY</span><span class="params">(<span class="keyword">int</span> in_y)</span></span>;</span><br><span class="line"><span class="comment">//得到x,y</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getX</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getY</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">int</span> y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p><code>point.cpp</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"point.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//设置x,y</span></span><br><span class="line"><span class="keyword">void</span> Point::setX(<span class="keyword">int</span> in_x)</span><br><span class="line">&#123;</span><br><span class="line">x = in_x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> Point::setY(<span class="keyword">int</span> in_y)</span><br><span class="line">&#123;</span><br><span class="line">y = in_y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//得到x,y</span></span><br><span class="line"><span class="keyword">int</span> Point::getX() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> Point::getY() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>头文件<code>circle.h</code><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once<span class="comment">//避免头文件被多次编译</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"point.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//圆类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//设置圆心和半径</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setCenter</span><span class="params">(Point in_center)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setR</span><span class="params">(<span class="keyword">int</span> in_r)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获得圆心和半径</span></span><br><span class="line"><span class="function">Point <span class="title">getCenter</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getR</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//比较点和圆的关系</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">isInCircle</span><span class="params">(Point p1)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">//圆心</span></span><br><span class="line">Point center;</span><br><span class="line"><span class="comment">//半径</span></span><br><span class="line"><span class="keyword">int</span> r;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p><code>circle.cpp</code><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"circle.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//设置圆心和半径</span></span><br><span class="line"><span class="keyword">void</span> Circle::setCenter(Point in_center)</span><br><span class="line">&#123;</span><br><span class="line">center = in_center;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> Circle::setR(<span class="keyword">int</span> in_r)</span><br><span class="line">&#123;</span><br><span class="line">r = in_r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获得圆心和半径</span></span><br><span class="line">Point Circle::getCenter() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> center;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> Circle::getR() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//比较点和圆的关系</span></span><br><span class="line"><span class="keyword">void</span> Circle::isInCircle(Point p1) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//点到圆心的距离的平方</span></span><br><span class="line"><span class="keyword">int</span> distance = (p1.getX() - center.getX())*(p1.getX() - center.getX()) + (p1.getY() - center.getY())*(p1.getY() - center.getY());</span><br><span class="line"></span><br><span class="line"><span class="comment">//半径的平方</span></span><br><span class="line"><span class="keyword">int</span> squareOfR = r*r;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断</span></span><br><span class="line"><span class="keyword">if</span> (distance == squareOfR)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"点在圆上。"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (distance &gt; squareOfR)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"点在圆外。"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"点在圆内。"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>02 面向对象设计案例—点和圆的关系.cpp</code><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; //标准输入输出流</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;<span class="comment">//使用命名空间 std</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"circle.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//需求分析：</span></span><br><span class="line"><span class="comment">//设计一个圆形类（AdvCircle），和一个点类（Point），计算点和圆的关系。</span></span><br><span class="line"><span class="comment">//假如圆心坐标为x0, y0, 半径为r，点的坐标为x1, y1：</span></span><br><span class="line"><span class="comment">//1）点在圆上：(x1 - x0)*(x1 - x0) + (y1 - y0)*(y1 - y0) == r*r</span></span><br><span class="line"><span class="comment">//2）点在圆内：(x1 - x0)*(x1 - x0) + (y1 - y0)*(y1 - y0) &lt; r*r</span></span><br><span class="line"><span class="comment">//3）点在圆外：(x1 - x0)*(x1 - x0) + (y1 - y0)*(y1 - y0) &gt; r*r</span></span><br><span class="line"><span class="comment">//采用分文件编写的方式！！！</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//测试函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//新建一个点</span></span><br><span class="line">Point p1;</span><br><span class="line">p1.setX(<span class="number">10</span>);</span><br><span class="line">p1.setY(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//新建一个圆心</span></span><br><span class="line">Point center;</span><br><span class="line">center.setX(<span class="number">10</span>);</span><br><span class="line">center.setY(<span class="number">0</span>);</span><br><span class="line"><span class="comment">//新建一个圆</span></span><br><span class="line">Circle c1;</span><br><span class="line">c1.setCenter(center);</span><br><span class="line">c1.setR(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断</span></span><br><span class="line">c1.isInCircle(p1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数入口</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">test01();</span><br><span class="line">system(<span class="string">"pause"</span>);<span class="comment">//阻塞功能</span></span><br><span class="line"><span class="keyword">return</span> EXIT_SUCCESS;<span class="comment">//返回正常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="3-构造函数和析构函数"><a href="#3-构造函数和析构函数" class="headerlink" title="3 构造函数和析构函数"></a>3 构造函数和析构函数</h1><p>构造函数主要作用在于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用。<br>析构函数主要用于<strong>对象销毁前</strong>系统自动调用，执行一些清理工作。<br><strong>构造函数分类</strong><br>按照参数分类：</p><ul><li>无参构造函数</li><li>有参构造函数</li></ul><p>按照类型分类：</p><ul><li>普通构造函数</li><li><strong>拷贝构造函数</strong></li></ul><p>拷贝构造函数的调用时机：</p><ul><li>用一个对象初始化另一个对象</li><li>对象以值传递的方式传给函数参数</li><li>函数局部对象以值传递的方式从函数返回(<code>vs debug</code>模式下调用一次拷贝构造，<code>qt</code>不调用任何构造)</li></ul><h1 id="4-浅拷贝和深拷贝"><a href="#4-浅拷贝和深拷贝" class="headerlink" title="4 浅拷贝和深拷贝"></a>4 浅拷贝和深拷贝</h1><h2 id="4-1-浅拷贝"><a href="#4-1-浅拷贝" class="headerlink" title="4.1 浅拷贝"></a>4.1 浅拷贝</h2><p>同一类型的对象之间可以赋值，使得两个对象的成员变量的值相同，两个对象仍然是独立的两个对象，这种情况被称为<strong>浅拷贝</strong>.<br>一般情况下，浅拷贝没有任何副作用，但是<strong>当类中有指针</strong>，并且指针指向动态分配的内存空间，析构函数做了动态内存释放的处理，产生指针悬挂，会导致内存问题。<br>浅拷贝示意图：<br><img src="/2019/02/27/CPP-day03/2.png" title="浅拷贝"></p><h2 id="4-2-深拷贝"><a href="#4-2-深拷贝" class="headerlink" title="4.2 深拷贝"></a>4.2 深拷贝</h2><p>当类中有指针，并且此指针有动态分配空间，析构函数做了释放处理，往往需要自定义拷贝构造函数，自行给指针动态分配空间，<strong>深拷贝</strong>。<br>深拷贝示意图：<br><img src="/2019/02/27/CPP-day03/3.png" title="深拷贝"></p><h1 id="5-多个对象的构造和析构"><a href="#5-多个对象的构造和析构" class="headerlink" title="5 多个对象的构造和析构"></a>5 多个对象的构造和析构</h1><h2 id="5-1-初始化列表"><a href="#5-1-初始化列表" class="headerlink" title="5.1 初始化列表"></a>5.1 初始化列表</h2><blockquote><p>注意：初始化成员列表（参数列表）只能在<strong>构造函数</strong>使用。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line"><span class="comment">//传统方式初始化</span></span><br><span class="line">Person(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)&#123;</span><br><span class="line">mA = a;</span><br><span class="line">mB = b;</span><br><span class="line">mC = c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">//初始化列表方式初始化</span></span><br><span class="line">Person(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c):mA(a),mB(b),mC(c)&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintPerson</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"mA:"</span> &lt;&lt; mA &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"mB:"</span> &lt;&lt; mB &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"mC:"</span> &lt;&lt; mC &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> mA;</span><br><span class="line"><span class="keyword">int</span> mB;</span><br><span class="line"><span class="keyword">int</span> mC;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="5-2-类对象作为成员"><a href="#5-2-类对象作为成员" class="headerlink" title="5.2 类对象作为成员"></a>5.2 类对象作为成员</h2><p>在类中定义的数据成员一般都是基本的数据类型。但是类中的成员也可以是对象，叫做<strong>对象成员</strong>。<br>C++中对象的初始化是非常重要的操作，当创建一个对象的时候，c++编译器必须确保调用了<strong>所有子对象的构造函数</strong>。如果所有的子对象有默认构造函数，编译器可以自动调用他们。但是如果子对象没有默认的构造函数，或者想指定调用某个构造函数怎么办？<br>那么是否可以在类的构造函数直接调用子类的属性完成初始化呢？但是如果子类的成员属性是私有的，我们是没有办法访问并完成初始化的。</p><blockquote><p>解决办法非常简单：对于子类调用构造函数，c++为此提供了专门的语法，即<strong>构造函数初始化列表</strong>。<br>当调用构造函数时，首先按各对象成员在类定义中的顺序（和参数列表的顺序无关）依次调用它们的构造函数，对这些对象初始化，最后再调用本身的函数体。也就是说，先调用对象成员的构造函数，再调用本身的构造函数。<br>析构函数和构造函数调用顺序相反，先构造，后析构。</p></blockquote><h1 id="6-explicit关键字"><a href="#6-explicit关键字" class="headerlink" title="6 explicit关键字"></a>6 explicit关键字</h1><p>C++提供了关键字explicit，禁止通过构造函数进行的隐式转换。声明为explicit的构造函数不能在隐式转换中使用。</p><blockquote><p>explicit注意</p><ul><li>修饰构造函数，防止隐式转化。</li><li>针对<strong>单参数</strong>的构造函数(或者除了第一个参数外其余参数都有默认值的多参构造)而言。</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">MyString</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"MyString(int n)!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">MyString(<span class="keyword">const</span> <span class="keyword">char</span>* str)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"MyString(const char* str)"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//给字符串赋值？还是初始化？</span></span><br><span class="line"><span class="comment">//MyString str1 = 1;//加了explicit，会报错Erro：不存在从int转换到MyString的适当构造函数</span></span><br><span class="line"><span class="function">MyString <span class="title">str2</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//寓意非常明确，给字符串赋值</span></span><br><span class="line">MyString str3 = <span class="string">"abcd"</span>;</span><br><span class="line"><span class="function">MyString <span class="title">str4</span><span class="params">(<span class="string">"abcd"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="7-动态对象的创建"><a href="#7-动态对象的创建" class="headerlink" title="7 动态对象的创建"></a>7 动态对象的创建</h1><blockquote><p>当我们创建数组的时候，总是需要提前预定数组的长度，然后编译器分配预定长度的数组空间，在使用数组的时，会有这样的问题，数组也许空间太大了，浪费空间，也许空间不足，所以对于数组来讲，如果能根据需要来分配空间大小再好不过。<br>所以动态意味着不确定性。</p></blockquote><p>当创建一个C++对象时会发生两件事:</p><ol><li>为对象分配内存</li><li>调用构造函数来初始化那块内存</li></ol><h2 id="7-1-new运算符"><a href="#7-1-new运算符" class="headerlink" title="7.1 new运算符"></a>7.1 new运算符</h2><p>C++中解决<strong>动态内存分配</strong>的方案是把创建一个对象所需要的操作都结合在一个称为<code>new</code>的运算符里。当用<code>new</code>创建一个对象时，它就在<strong><code>堆</code></strong>里为对象分配内存并调用<strong>构造函数</strong>完成初始化。<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Person</span>* <span class="keyword">person</span> = new <span class="keyword">Person</span>;</span><br></pre></td></tr></table></figure></p><p>相当于:<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Person</span>* <span class="keyword">person</span> = (<span class="keyword">Person</span>*)malloc(sizeof(<span class="keyword">Person</span>));</span><br><span class="line">if(<span class="keyword">person</span> == NULL)&#123;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">person</span>-&gt;Init();</span><br></pre></td></tr></table></figure></p><p>在堆里创建对象的过程变得简单了，只需要一个简单的表达式，它带有内置的长度计算、类型转换和安全检查。</p><h2 id="7-2-delete运算符"><a href="#7-2-delete运算符" class="headerlink" title="7.2 delete运算符"></a>7.2 delete运算符</h2><p>new表达式的反面是delete表达式。delete表达式先调用析构函数，然后释放内存。正如new表达式返回一个指向对象的指针一样，delete需要一个对象的地址。</p><h2 id="7-3-new和delete采用相同形式"><a href="#7-3-new和delete采用相同形式" class="headerlink" title="7.3 new和delete采用相同形式"></a>7.3 new和delete采用相同形式</h2><p>使用<code>new</code>和<code>delete</code>在<strong>堆</strong>上创建数组非常容易。<br><strong>当创建一个对象数组的时候，必须对数组中的每一个对象调用构造函数。</strong><br><code>new</code>配合<code>delete</code>，<code>new []</code>配合<code>delete []</code><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//栈区开辟</span></span><br><span class="line"><span class="comment">//Person p1;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在堆区开辟</span></span><br><span class="line">Person *p1 = <span class="keyword">new</span> Person;</span><br><span class="line"><span class="keyword">delete</span> p1;</span><br><span class="line">Person *p2 = <span class="keyword">new</span> Person[];</span><br><span class="line"><span class="keyword">delete</span> [] p1;</span><br><span class="line"><span class="comment">//所有new出来的对象都会返回该类型的指针</span></span><br><span class="line"><span class="comment">//malloc返回的是void* 需要进行强制类型转换</span></span><br><span class="line"><span class="comment">//malloc不会调用构造函数，new会调用构造函数</span></span><br><span class="line"><span class="comment">//new是一个运算符，malloc是一个函数</span></span><br><span class="line"><span class="comment">//释放堆区的空间，delete</span></span><br><span class="line"><span class="comment">//delete也是一个运算符</span></span><br><span class="line"><span class="comment">//molloc配合free，new配合delete</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;那些不能杀死我的，使我更强！&lt;br&gt;What does not kill me, makes me stronger.&lt;br&gt;——尼采（哲学家）
    
    </summary>
    
    
    
      <category term="C++" scheme="http://seaworth.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++ day02</title>
    <link href="http://seaworth.github.io/2019/02/26/CPP-day02/"/>
    <id>http://seaworth.github.io/2019/02/26/CPP-day02/</id>
    <published>2019-02-26T11:33:52.000Z</published>
    <updated>2019-04-14T08:51:57.319Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>人生中最大的两个财富是：你的<strong>才华</strong>和你的<strong>时间</strong>。<br>才华越来越多而时间越来越少。我们的一生就是用时间来换取才华。<a id="more"></a></p></blockquote><h1 id="1-extern-C浅析——C-中调用C"><a href="#1-extern-C浅析——C-中调用C" class="headerlink" title="1 extern C浅析——C++中调用C"></a>1 extern C浅析——C++中调用C</h1><p>在VS2010中新建工程<code>06 extern C浅析</code>，添加三个新建项</p><ul><li><code>test.h</code></li><li><code>test.c</code></li><li><code>06 extern C浅析.cpp</code><h2 id="1-1-在C语言代码中处理"><a href="#1-1-在C语言代码中处理" class="headerlink" title="1.1 在C语言代码中处理"></a>1.1 在C语言代码中处理</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus <span class="comment">//两个下划线__</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//一些用C语言实现的声明</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus <span class="comment">//两个下划线__</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></li></ul><blockquote><p>上面代码的含义是如果是C++编译器对C语言实现的test函数进行编译，则按照C语言编译，如果不是C++编译器则按照C语言正常处理。<br>如果要声明C语言的函数较多时，采用这种方法。</p></blockquote><p><code>test.h</code><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once <span class="comment">//防止头文件重复编译</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus <span class="comment">//两个下划线__</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;//包含基本的输入输出，C语言</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show1</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show2</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus <span class="comment">//两个下划线__</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></p><p><code>test.c</code><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"test.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"hello world\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"hello world1\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"hello world2\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>06 extern C浅析.cpp</code><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; //标准输入输出流</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;<span class="comment">//使用命名空间 std</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"test.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//C++中调用C语言方法</span></span><br><span class="line"><span class="comment">//extern "C" void show();//show方法，按照C语言方式做连接</span></span><br><span class="line"><span class="comment">//解决问题：在C++中调用C语言的函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//函数入口</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">show();<span class="comment">//C++中函数是可以发生重载，编译器会把这个函数名称偷偷改变</span></span><br><span class="line">show1();</span><br><span class="line">show2();</span><br><span class="line">system(<span class="string">"pause"</span>);<span class="comment">//阻塞功能</span></span><br><span class="line"><span class="keyword">return</span> EXIT_SUCCESS;<span class="comment">//返回正常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="1-2-在C-语言代码中处理"><a href="#1-2-在C-语言代码中处理" class="headerlink" title="1.2 在C++语言代码中处理"></a>1.2 在C++语言代码中处理</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C++中调用C语言方法</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;<span class="comment">//show方法，按照C语言方式做连接</span></span><br><span class="line"><span class="comment">//解决问题：在C++中调用C语言的函数</span></span><br></pre></td></tr></table></figure><blockquote><p>调用C语言实现的函数较少时，可采用这种方法。</p></blockquote><p><code>test.h</code><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once <span class="comment">//防止头文件重复编译</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;//包含基本的输入输出，C语言</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></p><p><code>test.c</code><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"test.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"hello world\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>06 extern C浅析.cpp</code><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; //标准输入输出流</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;<span class="comment">//使用命名空间 std</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//C++中调用C语言方法</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;<span class="comment">//show方法，按照C语言方式做连接</span></span><br><span class="line"><span class="comment">//解决问题：在C++中调用C语言的函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//函数入口</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">show();<span class="comment">//C++中函数是可以发生重载，编译器会把这个函数名称偷偷改变</span></span><br><span class="line"></span><br><span class="line">system(<span class="string">"pause"</span>);<span class="comment">//阻塞功能</span></span><br><span class="line"><span class="keyword">return</span> EXIT_SUCCESS;<span class="comment">//返回正常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="2-内联函数"><a href="#2-内联函数" class="headerlink" title="2 内联函数"></a>2 内联函数</h1><p>内联函数是为了解决宏定义的缺陷。<br>注意事项：</p><ol><li>内敛只是给编译器的一个小建议，加了inline编译器也不一定进行内联操作</li><li>没有进行inline声明，编译器也有可能优化，帮你进行内联编译</li><li>类的成员函数，编译器会自动添加inline</li></ol><h1 id="3-函数重载"><a href="#3-函数重载" class="headerlink" title="3 函数重载"></a>3 函数重载</h1><blockquote><p>默认参数：如果第一个位置有了默认参数，后面的必须要有默认参数。</p></blockquote><p>函数重载的注意事项：</p><ol><li>必须要在同一作用域下</li><li>函数的<strong>个数不同</strong>，<strong>参数类型不同</strong>，<strong>参数的顺序不同</strong></li><li><strong>函数的返回值不可以作为重载的条件</strong></li><li>const 可以作为重载的条件</li></ol><h1 id="4-C-的封装"><a href="#4-C-的封装" class="headerlink" title="4 C++的封装"></a>4 C++的封装</h1><blockquote><p>C语言的封装：属性和行为分开处理，类型检测不够强。<br>C++语言的封装：属性和行为绑在一起，严格的类型转换检测。</p><ol><li>属性和行为作为一个整体来表示生活中的事物</li><li>具有三种控制权限：public，protected，private</li><li>C++中struct和class是一个意思，但是struct的默认权限是<code>public</code>，class的默认权限是<code>private</code></li></ol></blockquote><p>总结：</p><ul><li>public，类的内部和外部都可以访问</li><li>protected，类的内部可以访问，类的外部不可以访问，子类可以访问</li><li>private，类的内部和外部都不可以访问，子类也不可以访问</li><li>建议类的成员属性设置为<code>private</code></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;人生中最大的两个财富是：你的&lt;strong&gt;才华&lt;/strong&gt;和你的&lt;strong&gt;时间&lt;/strong&gt;。&lt;br&gt;才华越来越多而时间越来越少。我们的一生就是用时间来换取才华。
    
    </summary>
    
    
    
      <category term="C++" scheme="http://seaworth.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>思考致富</title>
    <link href="http://seaworth.github.io/2019/02/26/%E6%80%9D%E8%80%83%E8%87%B4%E5%AF%8C/"/>
    <id>http://seaworth.github.io/2019/02/26/思考致富/</id>
    <published>2019-02-26T10:24:55.000Z</published>
    <updated>2019-03-09T11:37:38.218Z</updated>
    
    <content type="html"><![CDATA[<p>书中自有黄金屋，不断阅读，打开自己的思路与想法！<a id="more"></a></p><h1 id="决心——克服拖拉"><a href="#决心——克服拖拉" class="headerlink" title="决心——克服拖拉"></a>决心——克服拖拉</h1><blockquote><p>积累财富过百万美元的人都习惯于<strong>果断决策</strong>，然后根据需要再慢慢修改。<br>如何果断决策？<br>要自己做决定并努力实施，不要让他人知道你的想法，不要告诉任何人，除非是你特别信赖的人、与你志同道合的人。</p><p>经济上的自立、财富、理想的事业和社会地位，对于那些疏忽、不愿期待、不愿规划或不需要这些东西的人来说，是永远得不到的。</p></blockquote><h1 id="毅力——坚持不懈是信心的源泉"><a href="#毅力——坚持不懈是信心的源泉" class="headerlink" title="毅力——坚持不懈是信心的源泉"></a>毅力——坚持不懈是信心的源泉</h1><blockquote><p>多数人一遇到挫折和不幸就会放弃自己的目标。只有少数人才会在一切逆境面前坚持不懈，最终实现目标。他们把失败踩在脚下，把失败的惩罚视为强大的动力，因为每一次失败都蕴藏着一颗潜在成功的种子。</p></blockquote><p><strong>培养毅力</strong><br>毅力是一种心态，因而是可以被培养的。培养毅力的步骤如下：</p><ol><li><strong>明确的目标</strong>。培养毅力的第一步，也是最重要的一步，是知道自己想要什么。强烈的动机会驱使人克服任何困难。</li><li><strong>欲望</strong>。</li><li><strong>自信</strong>。</li><li><strong>明确的计划</strong>。条理清晰的计划是实现目标的必要条件。</li><li><strong>认清自我</strong>。</li><li><strong>合作</strong>。</li><li><strong>意志力</strong>。</li><li><strong>习惯</strong>。</li></ol><p><strong>如果害怕批评</strong></p><blockquote><p>多数人甘受亲人、朋友和其他人的影响，无法过自己想要的生活，因为<strong>他们害怕受到批评</strong>。<br>不少人选择了错误的人生伴侣，吵吵闹闹是家常便饭，痛苦不幸地度过一生，因为他们担心纠正婚姻中的错误会招致批评。很多人离开学校后疏于进一步接受教育，因为<strong>他们害怕批评</strong>。无数男女老少任凭亲人以责任为名毁了自己的生活，因为<strong>他们害怕批评</strong>。（责任并不需要任何人毁掉自己的抱负，剥夺自己想要追求想要生活的权利。就算会受到批评，也要全力保护自己的梦想。）</p></blockquote><h1 id="你唯一能掌握的东西"><a href="#你唯一能掌握的东西" class="headerlink" title="你唯一能掌握的东西"></a>你唯一能掌握的东西</h1><blockquote><p>你能掌握的东西只有一样，那就是你的意念。如果无法掌握自己的意志，那你也无法控制其他事物。意志控制是自律和习惯的结果。如果你不控制自己的意志，它就会控制你。控制意志最实际的办法就是让它保持忙碌，让它为了既定目标而忙于付诸行动计划。</p><p>爱默生说：“<strong>如果有缘，我们就会相遇。</strong>”最后，让我就用它的思想说：“<strong>假如有缘，通过blog，我们已经相遇。</strong>”</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;书中自有黄金屋，不断阅读，打开自己的思路与想法！
    
    </summary>
    
    
    
      <category term="随笔" scheme="http://seaworth.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>标幺值</title>
    <link href="http://seaworth.github.io/2019/02/26/%E6%A0%87%E5%B9%BA%E5%80%BC/"/>
    <id>http://seaworth.github.io/2019/02/26/标幺值/</id>
    <published>2019-02-26T04:44:19.000Z</published>
    <updated>2019-02-26T05:29:33.303Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>采用<strong>标幺值</strong>的目的：简化计算，方便对计算结果分析评价。<a id="more"></a></p></blockquote><h1 id="1-标幺值的概念"><a href="#1-标幺值的概念" class="headerlink" title="1 标幺值的概念"></a>1 标幺值的概念</h1><p>在一般的电路计算中，电压、电流、功率和阻抗的单位分别为V，A，W，Ω表示，这种用实际有名单位表示物理量的方法称为<strong><code>有名单位制</code></strong>。在电力系统计算中，还广泛使用<strong><code>标幺值</code></strong>。<br><img src="/2019/02/26/标幺值/绘图1.png" title="标幺值"> </p><p>如果我们选定电压的基准值为10.5kV，某发电机的端电压有名值表示为10.5kV，那么根据上式可得，发电机电压的标幺值为1。<br>注意事项：</p><ol><li>标幺值是一个没有量纲的数值</li><li>对于同一个实际有名值，基准值不同，其标幺值也不同</li><li>说一个量的标幺值时，必须同时说明它的基准值，否则，标幺值的意义不明确</li></ol><h1 id="2-基准值的选择"><a href="#2-基准值的选择" class="headerlink" title="2 基准值的选择"></a>2 基准值的选择</h1><p>基准值的选择，除了要求基准值和标幺值同单位外，尽量能够简化计算和便于对计算结果做出评价。</p><h1 id="3-参考文献"><a href="#3-参考文献" class="headerlink" title="3 参考文献"></a>3 参考文献</h1><blockquote><p>《电力系统分析》（上册）第三版，何仰赞，温增银</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;采用&lt;strong&gt;标幺值&lt;/strong&gt;的目的：简化计算，方便对计算结果分析评价。
    
    </summary>
    
    
    
      <category term="电力系统" scheme="http://seaworth.github.io/tags/%E7%94%B5%E5%8A%9B%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>面向对象方法</title>
    <link href="http://seaworth.github.io/2019/01/21/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%96%B9%E6%B3%95/"/>
    <id>http://seaworth.github.io/2019/01/21/面向对象方法/</id>
    <published>2019-01-21T13:20:29.000Z</published>
    <updated>2019-01-23T11:09:30.826Z</updated>
    
    <content type="html"><![CDATA[<p>这学期修了一门课程《面向对象方法》，不是为了学分而去学一门课，自己还是有所收获，现在把它总结记录下来。本课程老师上课也是用的<code>Linux</code>系统，讲授时也是直接敲代码给我们演示，给自己的印象比较深刻，老师比较专业的。自己练习和作业也是在<code>Ubuntu</code>的环境下实现，会用到vim编辑器，g++编译器。<a id="more"></a><br><img src="/2019/01/21/面向对象方法/面向对象方法.png" title="脑图"></p><h1 id="0-vim基本用法"><a href="#0-vim基本用法" class="headerlink" title="0 vim基本用法"></a>0 vim基本用法</h1><img src="/2019/01/21/面向对象方法/vim.jpg" title="vim">  <p>Vim是从vi发展出来的一个文本编辑器。Ubuntu下广泛使用。</p><h2 id="0-1-vim的示意图"><a href="#0-1-vim的示意图" class="headerlink" title="0.1 vim的示意图"></a>0.1 vim的示意图</h2><img src="/2019/01/21/面向对象方法/vim-vi-workmodel.png" title="vim-vi-workmodel">  <p>基本上vim共分为三种模式</p><ul><li>命令模式（Command mode）</li><li>输入模式（Insert mode）</li><li>底线命令模式（Last line mode）</li></ul><p>（注：操作在<strong>英文输入法</strong>下）<br>用户刚刚启动<code>vim</code>，便进入<code>命令模式</code>。此状态下敲击键盘动作会被vim识别为命令，而非输入字符。比如我们此时按下<code>i</code>，并不会输入一个字符，i被当作了一个命令。在命令模式下，按<code>i</code>切换到输入模式。在输入模式下，按<code>Esc</code>，回到命令模式。在命令模式下，<code>Shift+:</code>切换到底线命令模式。</p><h2 id="0-2-基本设置"><a href="#0-2-基本设置" class="headerlink" title="0.2 基本设置"></a>0.2 基本设置</h2><p>Vim的全局配置一般在<code>/etc/vim/vimrc</code>，对所有用户生效。如果只对单次编辑启用某个配置项，可以在命令模式下，先输入一个冒号，再输入配置。<br>下面进行全局配置，一劳永逸。<br>在<code>Terminal</code>下输入<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="keyword">vim</span> /etc/<span class="keyword">vim</span>/vimrc</span><br></pre></td></tr></table></figure></p><p>然后在文件末尾加上以下内容。<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> tabstop=<span class="number">4</span> <span class="comment">"设置tab键为4个空格</span></span><br><span class="line"><span class="keyword">set</span> softtabstop=<span class="number">4</span> <span class="comment">"逢4空格进1制表符</span></span><br><span class="line"><span class="keyword">set</span> <span class="built_in">shiftwidth</span>=<span class="number">4</span> <span class="comment">"自动缩进所使用的空白长度</span></span><br><span class="line"><span class="keyword">set</span> noexpandtab </span><br><span class="line"><span class="keyword">set</span> autoindent <span class="comment">"按下回车键后，下一行的缩进会自动跟上一行的缩进保持一致</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> nocompatible <span class="comment">"不与 Vi 兼容（采用 Vim 自己的操作命令）</span></span><br><span class="line"><span class="keyword">syntax</span> <span class="keyword">on</span> <span class="comment">"打开语法高亮</span></span><br><span class="line"><span class="keyword">set</span> showmode <span class="comment">"在底部显示，当前处于命令模式还是插入模式</span></span><br><span class="line"><span class="keyword">set</span> encoding=utf-<span class="number">8</span>  <span class="comment">"用 utf-8 编码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">number</span> <span class="comment">"设置行号</span></span><br></pre></td></tr></table></figure></p><h2 id="0-3-基本操作"><a href="#0-3-基本操作" class="headerlink" title="0.3 基本操作"></a>0.3 基本操作</h2><p>在<code>Terminal</code>下输入，新建hello.cpp文件。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">vim</span> <span class="selector-tag">hello</span><span class="selector-class">.cpp</span></span><br></pre></td></tr></table></figure></p><ol><li>此时进入了命令模式，按<code>i</code>，进入编辑模式，输入代码。</li><li><code>Esc</code>退出编辑模式，回到命令模式。</li><li><code>Shift+:</code>进入底线命令模式，底线命令模式下，<code>w</code>为保存，<code>q</code>为退出，<code>q!</code>为强制退出不保存。</li><li>在命令模式下，按<code>gg</code>回到文首，按<code>v</code>进入视图模式，<code>Shift+G</code>跳到文末，全选，<code>d</code>为删除，<code>c</code>为剪切，<code>y</code>为复制，<code>p</code>为粘贴。</li><li><code>dd</code>删除本行，<code>yy</code>复制本行，<code>cc</code>剪切本行.</li></ol><h1 id="1-makefile入门"><a href="#1-makefile入门" class="headerlink" title="1 makefile入门"></a>1 makefile入门</h1><h2 id="1-1-程序的编译和链接"><a href="#1-1-程序的编译和链接" class="headerlink" title="1.1 程序的编译和链接"></a>1.1 程序的编译和链接</h2><p>在Linux（unix）环境下使用GNU的make工具能够比较容易的构建一个属于你自己的工程，整个工程的编译只需要一个命令就可以完成编译、连接以至于最后的执行。不过这需要我们投入一些时间去完成一个或者多个称之为 Makefile 文件的编写。此文件正是 make 正常工作的基础。</p><p>Makefile文件描述了整个工程的编译、连接等规则。make是一个命令工具，它解释 Makefile 中的指令（应该说是规则）。编译整个工程你所要做的唯一的一件事就是在 shell 提示符下输入 make 命令。整个工程完全自动编译，极大提高了效率。</p><blockquote><p>准备知识<br><strong>编译</strong>：把高级语言书写的代码转换为机器可识别的机器指令。编译高级语言后生成的指令虽然可被机器识别，但是还不能被执行。编译时，编译器检查高级语言的语法、函数与变量的声明是否正确。只有所有的语法正确、相关变量定义正确编译器就可以编译出中间目标文件。通常，一个高级语言的源文件都可对应一个目标文件。目标文件在Linux 中默认后缀为“.o”。<br><strong>链接</strong>：将多.o 文件，或者.o 文件和库文件链接成为可被操作系统执行的可执行程序（Linux 环境下，可执行文件的格式为“ELF”格式）。链接器不检查函数所在的源文件，只检查所有.o 文件中的定义的符号。将.o 文件中使用的函数和其它.o 或者库文件中的相关符号进行合并，对所有文件中的符号进行重新安排（重定位），并链接系统相关文件（程序启动文件等）最终生成可执行程序。链接过程使用 GNU 的“ld”工具。  </p></blockquote><h2 id="1-2-小例子"><a href="#1-2-小例子" class="headerlink" title="1.2 小例子"></a>1.2 小例子</h2><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">seaworth<span class="variable">@ubuntu</span><span class="symbol">:~/Desktop/make_learning</span><span class="variable">$ </span>ls</span><br><span class="line">hello.cpp  hello.h  makefile</span><br></pre></td></tr></table></figure><p><code>hello.h</code><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"hello makefile!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>hello.cpp</code><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"hello.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    show();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>makefile</code><br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hello: hello.o</span><br><span class="line">    g++ -o hello hello.o</span><br><span class="line">hello<span class="selector-class">.o</span>: hello<span class="selector-class">.h</span> hello.cpp</span><br><span class="line">    g++ -c hello.cpp</span><br><span class="line">clean:</span><br><span class="line">    rm hello.o</span><br></pre></td></tr></table></figure></p><p>在<code>Terminal</code>下输入<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">seaworth<span class="variable">@ubuntu</span><span class="symbol">:~/Desktop/make_learning</span><span class="variable">$ </span>ls</span><br><span class="line">hello.cpp  hello.h  makefile</span><br><span class="line">seaworth<span class="variable">@ubuntu</span><span class="symbol">:~/Desktop/make_learning</span><span class="variable">$ </span>make</span><br><span class="line">g++ -c hello.cpp</span><br><span class="line">g++ -o hello hello.o</span><br><span class="line">seaworth<span class="variable">@ubuntu</span><span class="symbol">:~/Desktop/make_learning</span><span class="variable">$ </span>ls</span><br><span class="line">hello  hello.cpp  hello.h  hello.o  makefile</span><br><span class="line">seaworth<span class="variable">@ubuntu</span><span class="symbol">:~/Desktop/make_learning</span><span class="variable">$ </span>./hello</span><br><span class="line">hello makefile!</span><br></pre></td></tr></table></figure></p><h2 id="1-3-参考文档"><a href="#1-3-参考文档" class="headerlink" title="1.3 参考文档"></a>1.3 参考文档</h2><ul><li><a href="https://github.com/seisman/how-to-write-makefile" target="_blank" rel="noopener">《跟我一起写makefile》</a></li><li><a href="https://hacker-yhj.github.io/resources/gun_make.pdf" target="_blank" rel="noopener">《GNU make中文手册》</a></li></ul><h1 id="2-UML设计"><a href="#2-UML设计" class="headerlink" title="2 UML设计"></a>2 UML设计</h1><p>参考文档：<a href="https://design-patterns.readthedocs.io/zh_CN/latest/read_uml.html" target="_blank" rel="noopener">看懂UML类图和时序图</a></p><h1 id="3-C"><a href="#3-C" class="headerlink" title="3 C++"></a>3 C++</h1><h2 id="3-1-C-的精髓"><a href="#3-1-C-的精髓" class="headerlink" title="3.1 C++的精髓"></a>3.1 C++的精髓</h2><ul><li>抽象</li><li>封装</li><li>继承</li><li>多态</li></ul><h2 id="3-2-编程大作业"><a href="#3-2-编程大作业" class="headerlink" title="3.2 编程大作业"></a>3.2 编程大作业</h2><ul><li><strong>贪吃蛇</strong><br>针对Snake游戏，以UML完成需求分析到设计实现。</li></ul><ol><li>用C++语言编写</li><li>构建出UML用例图与类图</li><li>进行可视化编程，有良好的用户界面（使用NCURSES/SDL等）<br></li></ol><ul><li><strong>通信录备份</strong></li></ul><ol><li>实现可以将通信录备份到预先设定的服务器数据库中</li><li>数据库使用SQLite</li><li>同时备份到TF卡中</li><li>Android下通信部分用C++完成，界面用JAVA完成，之间采用JNI调用；iOS直接使用OBJECT C完成</li><li>需要有完整的设计文档（UML）<br><a href="https://lizhijun.site/2018/11/28/%E9%80%9A%E4%BF%A1%E5%BD%95%E5%A4%87%E4%BB%BD/" target="_blank" rel="noopener">通信录备份源码</a></li></ol><h2 id="3-3-C-基本语法"><a href="#3-3-C-基本语法" class="headerlink" title="3.3 C++基本语法"></a>3.3 C++基本语法</h2><p>推荐书籍：《C++ Primer 中文版（第5版）》</p><img src="/2019/01/21/面向对象方法/C++.jpg" title="C++ Primer">]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这学期修了一门课程《面向对象方法》，不是为了学分而去学一门课，自己还是有所收获，现在把它总结记录下来。本课程老师上课也是用的&lt;code&gt;Linux&lt;/code&gt;系统，讲授时也是直接敲代码给我们演示，给自己的印象比较深刻，老师比较专业的。自己练习和作业也是在&lt;code&gt;Ubuntu&lt;/code&gt;的环境下实现，会用到vim编辑器，g++编译器。
    
    </summary>
    
    
    
      <category term="C++" scheme="http://seaworth.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer-2 圆圈中最后剩下的数</title>
    <link href="http://seaworth.github.io/2019/01/20/%E5%89%91%E6%8C%87Offer-2/"/>
    <id>http://seaworth.github.io/2019/01/20/剑指Offer-2/</id>
    <published>2019-01-20T00:50:37.000Z</published>
    <updated>2019-09-10T02:23:32.835Z</updated>
    
    <content type="html"><![CDATA[<p>题目：孩子们的游戏(圆圈中最后剩下的数)<a id="more"></a><br><a href="https://www.nowcoder.com/practice/f78a359491e64a50bce2d89cff857eb6?tpId=13&amp;tqId=11199&amp;tPage=3&amp;rp=3&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">在线编程</a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><blockquote><p>每年六一儿童节,牛客都会准备一些小礼物去看望孤儿院的小朋友,今年亦是如此。HF作为牛客的资深元老,自然也准备了一些小游戏。其中,有个游戏是这样的:首先,让小朋友们围成一个大圈。然后,他随机指定一个数m,让编号为0的小朋友开始报数。每次喊到m-1的那个小朋友要出列唱首歌,然后可以在礼品箱中任意的挑选礼物,并且不再回到圈中,从他的下一个小朋友开始,继续0…m-1报数….这样下去….直到剩下最后一个小朋友,可以不用表演,并且拿到牛客名贵的“名侦探柯南”典藏版(名额有限哦!!^_^)。请你试着想下,哪个小朋友会得到这份礼品呢？(注：小朋友的编号是从0到n-1)</p></blockquote><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>模拟游戏的过程：规定数组中的值，1表示小朋友没有出列，-1表示已经出列。</p><ol><li>数组的所有值设为1</li><li>两个计数器countn，countm，每循环一次countn++，但只有数组中的值为1的时候，countm++，为-1的时候，countm不变（就相当于数到被出列的小朋友时，countm不计数）</li><li>简单的示意图如下<br><img src="/2019/01/20/剑指Offer-2/绘图1.png" title="This is an image"></li></ol><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">LastRemaining_Solution</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>((n&lt;<span class="number">1</span>)|(m&lt;<span class="number">1</span>))&#123;<span class="keyword">return</span> <span class="number">-1</span>;&#125;<span class="comment">//数据不规范</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> person[n];<span class="comment">//创建长度为n的数组，表示n小朋友</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            person[i]=<span class="number">1</span>;<span class="comment">//1表示小朋友还在环内，-1表示出局</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> countn=<span class="number">-1</span>,countm=<span class="number">0</span>,i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;n)</span><br><span class="line">        &#123;</span><br><span class="line">            countn++;</span><br><span class="line">            <span class="keyword">if</span> (countn&gt;=n)&#123;countn=<span class="number">0</span>;&#125;<span class="comment">//模拟环，数到最后一个小朋友</span></span><br><span class="line">            <span class="keyword">if</span>(person[countn]==<span class="number">-1</span>)&#123;<span class="keyword">continue</span>;&#125;<span class="comment">//这个小朋友已出局，跳过，不记录countm</span></span><br><span class="line">            countm++;</span><br><span class="line">            <span class="keyword">if</span>(countm==m)</span><br><span class="line">            &#123;</span><br><span class="line">                countm=<span class="number">0</span>;</span><br><span class="line">                i++;</span><br><span class="line">                person[countn]=<span class="number">-1</span>;<span class="comment">//小朋友出局</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> countn;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h1><blockquote><p>青山不改，流水长流！加油吧，少年！</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目：孩子们的游戏(圆圈中最后剩下的数)
    
    </summary>
    
    
    
      <category term="C++" scheme="http://seaworth.github.io/tags/C/"/>
    
      <category term="剑指" scheme="http://seaworth.github.io/tags/%E5%89%91%E6%8C%87/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer-1 和为S的两个数字</title>
    <link href="http://seaworth.github.io/2019/01/18/%E5%89%91%E6%8C%87Offer-1/"/>
    <id>http://seaworth.github.io/2019/01/18/剑指Offer-1/</id>
    <published>2019-01-18T12:38:54.000Z</published>
    <updated>2019-09-10T02:23:18.597Z</updated>
    
    <content type="html"><![CDATA[<p>题目：和为S的两个数字<a id="more"></a><br><a href="https://www.nowcoder.com/practice/f78a359491e64a50bce2d89cff857eb6?tpId=13&amp;tqId=11199&amp;tPage=3&amp;rp=3&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">在线编程</a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><blockquote><p>输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。</p></blockquote><h1 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述"></a>输出描述</h1><blockquote><p>对应每个测试案例，输出两个数，小的先输出。</p></blockquote><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>因为数组递增，采用两端紧逼法。设置头尾两个指针i和j。</p><ol><li>判断数组长度，长度小于2无法做乘法，直接返回数组</li><li>a[i]+a[j]&gt;sum，尾指针j减一，减小两数和的值</li><li>a[i]+a[j]&lt;sum，首指针i加一，增加两数和的值</li><li>a[i]+a[j]==sum，如果相等，直接返回，因为数组递增，相隔最远的两数乘积最小</li></ol><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; FindNumbersWithSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">array</span>,<span class="keyword">int</span> sum) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">int</span> len=<span class="built_in">array</span>.size();</span><br><span class="line">        <span class="keyword">if</span>(len&lt;<span class="number">2</span>)&#123;<span class="keyword">return</span> <span class="built_in">array</span>;&#125;<span class="comment">//数组长度小于2，无法两数做乘法</span></span><br><span class="line">        <span class="comment">//两端紧逼法</span></span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;<span class="comment">//左端下标</span></span><br><span class="line">        <span class="keyword">int</span> j=len<span class="number">-1</span>;<span class="comment">//右端下标</span></span><br><span class="line">        <span class="keyword">int</span> my_sum;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j)</span><br><span class="line">        &#123;</span><br><span class="line">            my_sum=<span class="built_in">array</span>[i]+<span class="built_in">array</span>[j];</span><br><span class="line">            <span class="keyword">if</span> (my_sum&gt;sum)</span><br><span class="line">            &#123;</span><br><span class="line">                j--;<span class="comment">//右端下标减一</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (my_sum&lt;sum)</span><br><span class="line">            &#123;</span><br><span class="line">                i++;<span class="comment">//左端下标加一</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                result.push_back(<span class="built_in">array</span>[i]);</span><br><span class="line">                result.push_back(<span class="built_in">array</span>[j]);</span><br><span class="line">                <span class="keyword">break</span>;<span class="comment">//找到后直接退出</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h1><blockquote><p>青山不改，流水长流！加油吧，少年！</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目：和为S的两个数字
    
    </summary>
    
    
    
      <category term="C++" scheme="http://seaworth.github.io/tags/C/"/>
    
      <category term="剑指" scheme="http://seaworth.github.io/tags/%E5%89%91%E6%8C%87/"/>
    
  </entry>
  
  <entry>
    <title>C++学习路线</title>
    <link href="http://seaworth.github.io/2019/01/11/CPP%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"/>
    <id>http://seaworth.github.io/2019/01/11/CPP学习路线/</id>
    <published>2019-01-11T14:24:43.000Z</published>
    <updated>2019-02-24T14:17:21.547Z</updated>
    
    <content type="html"><![CDATA[<p>成长为一名合格的程序员，需要一条合适的学习线路。今天在微信上看到一篇文章《三位斩获百度C++后台开发Offer大佬的口述分享！！！》，希望能在C++学习的漆黑的道路上点亮一盏明灯~<a id="more"></a></p><h1 id="1-C"><a href="#1-C" class="headerlink" title="1.C++"></a>1.C++</h1><p>C++方面就是把<strong>《C++ Primer》《Effective C++》《STL源码》</strong>这三本书都看了一遍，大佬们原话都是这样说的：“这三本书都看一遍，然后上面的所有的 知识记住，面试官问的C++问题还没有不会的”。这里画重点了，不仅仅要看一遍，上面的三本书的知识得印在脑海，那么面试的时候吊打面试官提出的任何C++问题。</p><h1 id="2-其他"><a href="#2-其他" class="headerlink" title="2.其他"></a>2.其他</h1><p>学完基础知识后，最重要的是提高自己的算法能力。Talk is cheap, show your code!<br>数据库，操作系统，计算机网络，数据结构与算法，Linux，走起。</p><h2 id="2-1-数据结构与算法"><a href="#2-1-数据结构与算法" class="headerlink" title="2.1 数据结构与算法"></a>2.1 数据结构与算法</h2><p>书籍推荐<br><strong>《大话数据结构》</strong>：这本书通俗易懂，第五章可以不看，面试的时候KMP算法被问到的几率比较小，笔试中可能会遇到，但是KMP算法能解决的问题DP大概率也可以解决，要求高的同学可以看看。第七章图，面试中问得比较少，但是在笔试中大概率会遇到，所以还是的认真看。<br>《算法》<br>《啊哈算法》<br>《图解算法》<br>这两本书图文并茂，对新手比较友好。<br>《剑指offer》<br>面试宝典，大多数公司的面试题都会从里面出。剑指offer在牛客网上有对应的Online Judge系统（OJ）<br>视频推荐<br>《牛客网左神视频》+左神的书《程序员代码面试指南 IT名企算法与数据结构题目最优解》<br>leedcode<br>每天一道，日积月累。</p><h2 id="2-2-计算机网络"><a href="#2-2-计算机网络" class="headerlink" title="2.2 计算机网络"></a>2.2 计算机网络</h2><p>推荐书籍：<br>《计算机网络（谢希仁）》第六版<br>最常见的问题：OSI七层模型，每层是做什么的，或五层协议栈每层的作用，TCP和UDP的区别，拥塞控制和流量控制，TCP三次握手和四次挥手。<br>推荐章节：前六章都建议看，<strong>第一章1.7是重点</strong>，其他作为了解，预备知识，有个了解就好；第二章：2.1、2.2、2.4建议看，2.6作为补充；第三章：看前三节，后两节可以不看；第四章：看前五小节和4.7小节；<strong>第五章都要看，重点</strong>；第六章：从6.1开始，看完6.4.3和6.6，第六章主要是应用层协议，协议比较多，建议都翻一下，大致了解协议的用途功能就好了。</p><p>《计算机网络：自顶向下方法》<br>深入浅出，幽默生动。没有数学书上那种死板的定义和公式，更多的时候是大段大段的讲解，非常形象，像看小说一般，酣畅淋漓，很快就看完了一本。</p><p>然后就是图解系列，《图解HTTP》《图解TCP/IP》，大量的图的插画，形象生动，不知不觉就学到了很多，通俗易懂，业界良心。</p><p>其实还有一本大厚书也得提一下，《TCP/IP协议卷1》，适合后期观看。</p><h2 id="2-3-数据库"><a href="#2-3-数据库" class="headerlink" title="2.3 数据库"></a>2.3 数据库</h2><p>《MySQL必知必会》，看完这本书把牛客网的专题刷下。</p><h2 id="2-4-设计模式"><a href="#2-4-设计模式" class="headerlink" title="2.4 设计模式"></a>2.4 设计模式</h2><p>推荐书籍：<br><strong>《大话设计模式》</strong><br>学完一种设计模式后，最好找到JDK或Spring或其他框架源码中的应用。这有助于理解和加深记忆，重要的是，如果面试官问你设计模式的时候，你能说出几种常见的设计模式，并能够给出框架源码中的应用，以及该模式解决了什么问题，会让面试官觉得你的知识体系比较完善，是一个加分项。</p><p>常见的设计模式问题：<strong>单例、适配器、装饰者、代理、组合、策略、模板方法、观察者、工厂方法</strong>，这几个是重点，<strong>强调，每一种模式都要能举出一两种应用的场景</strong>。</p><h2 id="2-5-Linux"><a href="#2-5-Linux" class="headerlink" title="2.5 Linux"></a>2.5 Linux</h2><p>推荐书籍：<br><strong>《鸟哥的Linux私房菜（基础学习篇）》</strong><br>这本书口碑好，适合初学者，通俗易懂。Linux主要考察常用命令、文件权限、虚拟内存、软硬链接等。强烈建议安装一个虚拟机VM，Ubuntu虚拟机安装或Centos虚拟机安装。先看书的第0、1、2章，第3章的分区，第0、1、2、3章大致看看，第5章是基本的使用命令，第6章<strong>权限</strong>是考察的重点，第7章，第8章（ext文件系统了解即可，关注下磁盘常用的命令），<strong>第9章，第10章建议看</strong>，20.1小节可以看看，其他没提到的部分可以先不看。</p><h1 id="3-总结"><a href="#3-总结" class="headerlink" title="3.总结"></a>3.总结</h1><p>上面的所说的知识记住并理解，《剑指offer》上面的题都会做，自己的项目好好准备一下，拿到理想的offer~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;成长为一名合格的程序员，需要一条合适的学习线路。今天在微信上看到一篇文章《三位斩获百度C++后台开发Offer大佬的口述分享！！！》，希望能在C++学习的漆黑的道路上点亮一盏明灯~
    
    </summary>
    
    
    
      <category term="C++" scheme="http://seaworth.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>父亲的寄语</title>
    <link href="http://seaworth.github.io/2019/01/02/%E7%88%B6%E4%BA%B2%E7%9A%84%E5%AF%84%E8%AF%AD/"/>
    <id>http://seaworth.github.io/2019/01/02/父亲的寄语/</id>
    <published>2019-01-02T13:55:07.000Z</published>
    <updated>2019-01-02T14:13:58.630Z</updated>
    
    <content type="html"><![CDATA[<p>今天父亲发来一张图片，上面写着：爸爸40多岁了，能力有限，今生做我的儿子，委屈你了，有几句心里话对你说。</p><h1 id="1-父亲对儿子的寄语"><a href="#1-父亲对儿子的寄语" class="headerlink" title="1.父亲对儿子的寄语"></a>1.父亲对儿子的寄语</h1><ol><li>做人要诚实，待人要诚信。</li><li>天上不会掉馅饼，一份耕耘一份收获。</li><li>天道酬勤，勤奋是生存的基础，也是生活的根本。</li><li>一生中没有人有义务对你好，除了我和你妈。<a id="more"></a>最后我要说，亲人只有一次缘分，无论这辈子我和你相处多久，都请好好珍惜共聚的时光，下辈子无论爱与不爱，都不会再见。</li></ol><h1 id="2-马云奉劝年轻人的五句话"><a href="#2-马云奉劝年轻人的五句话" class="headerlink" title="2.马云奉劝年轻人的五句话"></a>2.马云奉劝年轻人的五句话</h1><ol><li>人活着，谁都不用瞧不起谁，三十年河东三十年河西，潮起潮又落。</li><li>不要因为没有掌声而放弃梦想，你需要的是坚持而不是观众。</li><li>永远别做别人的备选，如果你不是他的首选，那他们根本一开始就配不上你。</li><li>你不可能让所有人都喜欢你，你只要做好自己，带给爱你的人和你爱的人，快乐和幸福就够了。</li><li>人生可以追求，但切莫攀比，你虚荣可以，但一定要靠自己。</li></ol><p>相信这也是我父亲的内心话，触动了心里的那根弦，才会截图发给我。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天父亲发来一张图片，上面写着：爸爸40多岁了，能力有限，今生做我的儿子，委屈你了，有几句心里话对你说。&lt;/p&gt;
&lt;h1 id=&quot;1-父亲对儿子的寄语&quot;&gt;&lt;a href=&quot;#1-父亲对儿子的寄语&quot; class=&quot;headerlink&quot; title=&quot;1.父亲对儿子的寄语&quot;&gt;&lt;/a&gt;1.父亲对儿子的寄语&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;做人要诚实，待人要诚信。&lt;/li&gt;
&lt;li&gt;天上不会掉馅饼，一份耕耘一份收获。&lt;/li&gt;
&lt;li&gt;天道酬勤，勤奋是生存的基础，也是生活的根本。&lt;/li&gt;
&lt;li&gt;一生中没有人有义务对你好，除了我和你妈。
    
    </summary>
    
    
    
      <category term="随笔" scheme="http://seaworth.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>C++ day01</title>
    <link href="http://seaworth.github.io/2018/12/16/CPP-day01/"/>
    <id>http://seaworth.github.io/2018/12/16/CPP-day01/</id>
    <published>2018-12-16T13:37:07.000Z</published>
    <updated>2019-04-14T08:54:43.040Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>世上只有一种英雄主义——就是在认清生活的真相之后依然热爱生活。——罗曼.罗兰（作家 诺贝尔奖得主）<a id="more"></a></p><h1 id="1-C-概述"><a href="#1-C-概述" class="headerlink" title="1.C++概述"></a>1.C++概述</h1><p>C++是C的超集，是C的补充和扩展，兼容C。<br><strong>C++和C的区别：</strong></p><ul><li>C：面向过程。（功能分解，自顶向下，逐层分解），程序=算法+数据结构</li><li>C++：面向对象。（一切皆对象），对象=算法+数据结构，程序=对象+对象</li></ul></blockquote><p><strong>面向对象三大特性：</strong></p><ul><li>封装，“抽象”</li><li>继承</li><li>多态，“一个接口，多种方法”</li></ul><h1 id="2-namespace命名空间"><a href="#2-namespace命名空间" class="headerlink" title="2.namespace命名空间"></a>2.namespace命名空间</h1><ul><li>用来解决命名冲突</li><li>必须在全局作用域下声明</li><li>命名空间下可以放函数、变量、结构体、类</li><li>命名空间可以嵌套命名空间</li><li>命名空间是开放的，随时可以添加新的成员</li><li>存在匿名空间</li></ul><h1 id="3-using声明和using编译"><a href="#3-using声明和using编译" class="headerlink" title="3.using声明和using编译"></a>3.using声明和using编译</h1><h2 id="3-1-using声明"><a href="#3-1-using声明" class="headerlink" title="3.1 using声明"></a>3.1 using声明</h2><p><strong>using KingGlory::sunwukongID;</strong>说明<strong>sunwukongID</strong>使用<strong>KingGlory</strong>下的。<br>编译器有就近原则，需要避免二义性。</p><h2 id="3-2-using编译"><a href="#3-2-using编译" class="headerlink" title="3.2 using编译"></a>3.2 using编译</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//using编译指令</span></span><br><span class="line"><span class="comment">//就近原则 大于 打开房间</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> KingGlory;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> LOL;</span><br><span class="line"><span class="comment">//如果打开多个房间，要避免二义性，明确指明变量的命名空间</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; LOL::sunwukongID &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;世上只有一种英雄主义——就是在认清生活的真相之后依然热爱生活。——罗曼.罗兰（作家 诺贝尔奖得主）
    
    </summary>
    
    
    
      <category term="C++" scheme="http://seaworth.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>定制域名</title>
    <link href="http://seaworth.github.io/2018/11/29/%E5%AE%9A%E5%88%B6%E5%9F%9F%E5%90%8D/"/>
    <id>http://seaworth.github.io/2018/11/29/定制域名/</id>
    <published>2018-11-29T06:53:13.000Z</published>
    <updated>2018-11-29T07:25:40.479Z</updated>
    
    <content type="html"><![CDATA[<p>最近给自己的博客换了一个新的域名，在新添加博客文章的时候出现了问题。记录下来~<a id="more"></a></p><h1 id="1-购买域名"><a href="#1-购买域名" class="headerlink" title="1.购买域名"></a>1.购买域名</h1><p>在阿里云购买了域名lizhijun.site并进行解析。</p><ul><li>首先ping Seaworth.github.io，得到博客的IP地址</li></ul><img src="/2018/11/29/定制域名/IP地址.png" title="This is an example image"><img src="/2018/11/29/定制域名/1.png" title="This is an example image"><h1 id="2-Github的设置"><a href="#2-Github的设置" class="headerlink" title="2.Github的设置"></a>2.Github的设置</h1><ul><li>在Seaworth.github.io仓库的Settings中添加新域名</li></ul><img src="/2018/11/29/定制域名/2.png" title="This is an example image"><h1 id="3-本地修改"><a href="#3-本地修改" class="headerlink" title="3.本地修改"></a>3.<strong>本地修改</strong></h1><p>本地修改很重要，不然新添加博客，hexo d后会出现404页面。</p><h2 id="3-1-F-blog-source目录下添加CNAME文件"><a href="#3-1-F-blog-source目录下添加CNAME文件" class="headerlink" title="3.1 F:\blog\source目录下添加CNAME文件"></a>3.1 F:\blog\source目录下添加CNAME文件</h2><img src="/2018/11/29/定制域名/3.png" title="This is an example image"><h2 id="3-2-CNAME文件写新的域名"><a href="#3-2-CNAME文件写新的域名" class="headerlink" title="3.2 CNAME文件写新的域名"></a>3.2 CNAME文件写新的域名</h2><p>lizhijun.site<br><img src="/2018/11/29/定制域名/4.png" title="This is an example image"></p><h2 id="3-3-添加新的博客"><a href="#3-3-添加新的博客" class="headerlink" title="3.3 添加新的博客"></a>3.3 添加新的博客</h2><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">hexo g</span></span><br><span class="line"><span class="attribute">hexo d</span></span><br></pre></td></tr></table></figure><h1 id="4-参考"><a href="#4-参考" class="headerlink" title="4.参考"></a>4.参考</h1><p>[1] <a href="https://blog.csdn.net/qq_38332436/article/details/81907686" target="_blank" rel="noopener">hexo d 部署后总需要重新改域名解决</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近给自己的博客换了一个新的域名，在新添加博客文章的时候出现了问题。记录下来~
    
    </summary>
    
    
    
      <category term="hexo" scheme="http://seaworth.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>通信录备份</title>
    <link href="http://seaworth.github.io/2018/11/28/%E9%80%9A%E4%BF%A1%E5%BD%95%E5%A4%87%E4%BB%BD/"/>
    <id>http://seaworth.github.io/2018/11/28/通信录备份/</id>
    <published>2018-11-28T14:11:32.000Z</published>
    <updated>2018-11-29T06:44:30.563Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-设计要求"><a href="#1-设计要求" class="headerlink" title="1.设计要求"></a>1.设计要求</h1><ul><li>语言C++</li><li>编程环境Ubuntu</li><li>客户端的通信录备份到服务器</li><li>数据库使用sqlite3</li><li><strong><a href="https://github.com/Seaworth/contacts_backup" target="_blank" rel="noopener">源码下载</a></strong><a id="more"></a><h1 id="2-创建数据库"><a href="#2-创建数据库" class="headerlink" title="2.创建数据库"></a>2.创建数据库</h1></li><li>源文件create_table.cpp</li><li>在服务器端创建数据库test.db</li><li>添加表CONTACTS，创建字段ID,NAME,TEL<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sqlite3.h&gt; </span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">callback</span><span class="params">(<span class="keyword">void</span> *NotUsed, <span class="keyword">int</span> argc, <span class="keyword">char</span> **argv, <span class="keyword">char</span> **azColName)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;argc; i++)&#123;</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">"%s = %s\n"</span>, azColName[i], argv[i] ? argv[i] : <span class="string">"NULL"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sqlite3 *db;</span><br><span class="line">    <span class="keyword">char</span> *zErrMsg = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>  rc;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *sql;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Open database */</span></span><br><span class="line">    rc = sqlite3_open(<span class="string">"test.db"</span>, &amp;db);</span><br><span class="line">    <span class="keyword">if</span>( rc )&#123;</span><br><span class="line">       <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Can't open database: %s\n"</span>, sqlite3_errmsg(db));</span><br><span class="line">       <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">       <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">"Opened database successfully\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Create SQL statement */</span></span><br><span class="line">    sql = <span class="string">"CREATE TABLE CONTACTS("</span>  \</span><br><span class="line">          <span class="string">"ID INT PRIMARY KEY     NOT NULL,"</span> \</span><br><span class="line">          <span class="string">"NAME           TEXT    NOT NULL,"</span> \</span><br><span class="line">          <span class="string">"TEL            TEXT    NOT NULL);"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Execute SQL statement */</span></span><br><span class="line">    rc = sqlite3_exec(db, sql, callback, <span class="number">0</span>, &amp;zErrMsg);</span><br><span class="line">    <span class="keyword">if</span>( rc != SQLITE_OK )&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"SQL error: %s\n"</span>, zErrMsg);</span><br><span class="line">        sqlite3_free(zErrMsg);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">"Table created successfully\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sqlite3_close(db);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="3-服务器接收数据"><a href="#3-服务器接收数据" class="headerlink" title="3.服务器接收数据"></a>3.服务器接收数据</h1><ul><li>源文件server.cpp</li><li>打开数据库test.db，读取已有的联系人个数</li><li>通过socket接收客户端发来的数据</li><li>打开数据库test.db，将数据保存到数据库中</li><li>关闭数据库<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sqlite3.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLINE 4096</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERVER_PORT 6666<span class="comment">//服务器端口号</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">callback</span><span class="params">(<span class="keyword">void</span> *NotUsed, <span class="keyword">int</span> argc, <span class="keyword">char</span> **argv, <span class="keyword">char</span> **azColName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;argc; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s = %s\n"</span>, azColName[i], argv[i] ? argv[i] : <span class="string">"NULL"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    sqlite3 *db;</span><br><span class="line">    <span class="keyword">char</span> *zErrMsg = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>  rc;</span><br><span class="line">    <span class="keyword">char</span> *sql;</span><br><span class="line">    <span class="keyword">int</span> id = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>  listenfd, connfd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span>  <span class="title">servaddr</span>;</span></span><br><span class="line">    <span class="keyword">char</span>  buff[<span class="number">4096</span>];</span><br><span class="line">    <span class="keyword">int</span>  n;  </span><br><span class="line">    <span class="comment">/* Open database */</span></span><br><span class="line">    rc = sqlite3_open(<span class="string">"test.db"</span>, &amp;db);</span><br><span class="line">    <span class="keyword">if</span> (rc == SQLITE_OK)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> sql[<span class="number">256</span>] = <span class="string">"SELECT * FROM CONTACTS"</span>;</span><br><span class="line">        <span class="keyword">char</span>** pResult;</span><br><span class="line">        <span class="keyword">int</span> nRow;</span><br><span class="line">        <span class="keyword">int</span> nCol;</span><br><span class="line">        rc = sqlite3_get_table(db, sql, &amp;pResult, &amp;nRow, &amp;nCol, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (rc == SQLITE_OK)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nRow &gt;= <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"now the number of contact is "</span> &lt;&lt; nRow &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                id=nRow+<span class="number">1</span>;<span class="comment">//在此数据后追加数据</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sqlite3_free_table(pResult);</span><br><span class="line">    &#125;</span><br><span class="line">    sqlite3_close(db);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( (listenfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>)) == <span class="number">-1</span> )&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"create socket error: %s(errno: %d)\n"</span>,strerror(errno),errno);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在服务端bind or listen前</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> value = <span class="number">0x1</span>;</span><br><span class="line">    setsockopt(listenfd,SOL_SOCKET,SO_REUSEADDR,(<span class="keyword">void</span> *)&amp;value,<span class="keyword">sizeof</span>(value));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化servaddr</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;servaddr, <span class="number">0</span>, <span class="keyword">sizeof</span>(servaddr));<span class="comment">//清空结构体变量</span></span><br><span class="line">    servaddr.sin_family = AF_INET;<span class="comment">//主机字节序列</span></span><br><span class="line">    servaddr.sin_addr.s_addr = htonl(INADDR_ANY);<span class="comment">//INADDR_ANY表示本机的任意IP</span></span><br><span class="line">    servaddr.sin_port = htons(SERVER_PORT);<span class="comment">//端口号6666</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( bind(listenfd, (struct sockaddr*)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr)) == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"bind socket error: %s(errno: %d)\n"</span>,strerror(errno),errno);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( listen(listenfd, <span class="number">10</span>) == <span class="number">-1</span>)&#123;<span class="comment">//最多有10个用户处于连接等待状态</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"listen socket error: %s(errno: %d)\n"</span>,strerror(errno),errno);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"======Start backing up to database======\n"</span>);  </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">//NULL 表示不关心客户端的地址</span></span><br><span class="line">        <span class="keyword">if</span>( (connfd = accept(listenfd, (struct sockaddr*)<span class="literal">NULL</span>, <span class="literal">NULL</span>)) == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"accept socket error: %s(errno: %d)"</span>,strerror(errno),errno);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        n = recv(connfd, buff, MAXLINE, <span class="number">0</span>);<span class="comment">//buff保存传来的数据</span></span><br><span class="line">        buff[n] = <span class="string">'\0'</span>;</span><br><span class="line">        <span class="comment">//printf("recv msg from client: %s\n", buff);</span></span><br><span class="line">        close(connfd);</span><br><span class="line">        <span class="keyword">char</span> *name;<span class="comment">//联系人的名字</span></span><br><span class="line">        <span class="keyword">char</span> *tel;<span class="comment">//联系人的电话</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *delim = <span class="string">"\n"</span>;</span><br><span class="line">        name = strtok(buff, delim);</span><br><span class="line">        tel = strtok(<span class="literal">NULL</span>, delim);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt;id&lt;&lt;<span class="built_in">endl</span>&lt;&lt;<span class="string">"recv msg from client:"</span> &lt;&lt; name &lt;&lt;<span class="string">" "</span>&lt;&lt;tel&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Open database */</span></span><br><span class="line">        rc = sqlite3_open(<span class="string">"test.db"</span>, &amp;db);</span><br><span class="line">        <span class="keyword">if</span>( rc )&#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Can't open database: %s\n"</span>, sqlite3_errmsg(db));</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">"Opened database successfully\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* Create SQL statement */</span></span><br><span class="line">        <span class="keyword">char</span> BUFF[<span class="number">200</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="built_in">sprintf</span> (BUFF, <span class="string">"INSERT INTO CONTACTS(ID,NAME,TEL)"</span> <span class="string">"VALUES (%d, '%s', '%s');"</span>, id++, name, tel);</span><br><span class="line">        rc = sqlite3_exec(db, BUFF, callback, <span class="number">0</span>, &amp;zErrMsg);</span><br><span class="line">        <span class="keyword">if</span>( rc != SQLITE_OK ) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"SQL error: %s\n"</span>, zErrMsg);</span><br><span class="line">            sqlite3_free(zErrMsg);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">"Records created successfully\n"</span>);</span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    close(listenfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="3-客户端发送数据"><a href="#3-客户端发送数据" class="headerlink" title="3.客户端发送数据"></a>3.客户端发送数据</h1><ul><li>源代码client.cpp</li><li>通过socket发送数据到服务器<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLINE 4096</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>   sockfd, n;</span><br><span class="line">    <span class="keyword">char</span>  recvline[<span class="number">4096</span>];</span><br><span class="line">    <span class="keyword">char</span>* sendline;</span><br><span class="line">    <span class="keyword">char</span> contacts[<span class="number">3</span>][<span class="number">100</span>] =&#123;<span class="string">"zhangsan\n18883993801"</span>,<span class="string">"lisi\n1883993802"</span>,<span class="string">"wangwu\n18883993803"</span>&#125;;<span class="comment">//三个联系人</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span>  <span class="title">servaddr</span>;</span></span><br><span class="line">    <span class="keyword">char</span> serverIP[]=<span class="string">"127.0.0.1"</span>;<span class="comment">//服务器IP，本地通信IP:127.0.0.1</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;servaddr, <span class="number">0</span>, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">    servaddr.sin_family = AF_INET;</span><br><span class="line">    servaddr.sin_port = htons(<span class="number">6666</span>);<span class="comment">//服务器的端口号 </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">            sendline=contacts[i];</span><br><span class="line">            <span class="keyword">if</span>( (sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"create socket error: %s(errno: %d)\n"</span>, strerror(errno),errno);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>( inet_pton(AF_INET, serverIP, &amp;servaddr.sin_addr) &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"inet_pton error for %s\n"</span>,serverIP);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>( connect(sockfd, (struct sockaddr*)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"connect error: %s(errno: %d)\n"</span>,strerror(errno),errno);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"send msg to server: %s \n"</span>,sendline);</span><br><span class="line">            <span class="comment">//fgets(sendline, 4096, stdin);</span></span><br><span class="line">            <span class="keyword">if</span>( send(sockfd, sendline, <span class="built_in">strlen</span>(sendline), <span class="number">0</span>) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"send msg error: %s(errno: %d)\n"</span>, strerror(errno), errno);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            close(sockfd);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="4-运行结果"><a href="#4-运行结果" class="headerlink" title="4.运行结果"></a>4.运行结果</h1><ul><li><p>先创建数据库</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g++ -o create_table create_table<span class="selector-class">.cpp</span> -l sqlite3</span><br><span class="line">./create_table</span><br></pre></td></tr></table></figure></li><li><p>再运行服务器</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g++ -o<span class="built_in"> server </span>server.cpp -l sqlite3</span><br><span class="line">./server</span><br></pre></td></tr></table></figure></li><li><p>再运行客户端</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g++ -o<span class="built_in"> client </span>client.cpp</span><br><span class="line">./client</span><br></pre></td></tr></table></figure></li><li><p>客户端发送，服务器接收</p><img src="/2018/11/28/通信录备份/socket.png" title="This is an example image"></li><li><p>查看数据库</p><img src="/2018/11/28/通信录备份/sqlite.PNG" title="This is an example image"><h1 id="5-参考"><a href="#5-参考" class="headerlink" title="5.参考"></a>5.参考</h1><p>[1] <a href="http://www.runoob.com/sqlite/sqlite-tutorial.html" target="_blank" rel="noopener">菜鸟教程</a><br>[2] <a href="http://www.cnblogs.com/zkfopen/p/9441264.html" target="_blank" rel="noopener">Linux C++ TCP Socket通信实例</a><br>[3] <a href="http://dufaxing.com/2018/11/15/address-book-backup/#%E5%B0%86%E9%80%9A%E8%AE%AF%E5%BD%95%E4%B8%8A%E4%BC%A0%E8%87%B3%E6%9C%8D%E5%8A%A1%E5%99%A8]" target="_blank" rel="noopener">Android调用CPP接口实现通讯录上传与备份</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-设计要求&quot;&gt;&lt;a href=&quot;#1-设计要求&quot; class=&quot;headerlink&quot; title=&quot;1.设计要求&quot;&gt;&lt;/a&gt;1.设计要求&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;语言C++&lt;/li&gt;
&lt;li&gt;编程环境Ubuntu&lt;/li&gt;
&lt;li&gt;客户端的通信录备份到服务器&lt;/li&gt;
&lt;li&gt;数据库使用sqlite3&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&quot;https://github.com/Seaworth/contacts_backup&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;源码下载&lt;/a&gt;&lt;/strong&gt;
    
    </summary>
    
    
    
      <category term="C++" scheme="http://seaworth.github.io/tags/C/"/>
    
      <category term="socket" scheme="http://seaworth.github.io/tags/socket/"/>
    
      <category term="sqlite3" scheme="http://seaworth.github.io/tags/sqlite3/"/>
    
  </entry>
  
  <entry>
    <title>破解VIP会员视频</title>
    <link href="http://seaworth.github.io/2018/03/11/%E7%A0%B4%E8%A7%A3VIP%E4%BC%9A%E5%91%98%E8%A7%86%E9%A2%91/"/>
    <id>http://seaworth.github.io/2018/03/11/破解VIP会员视频/</id>
    <published>2018-03-11T12:03:55.000Z</published>
    <updated>2018-12-12T13:31:26.963Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、前言"><a href="#1、前言" class="headerlink" title="1、前言"></a>1、前言</h3><p>这次给追剧的同学带来一个福利，一键破解[优酷|腾讯|乐视|爱奇艺]等VIP或会员视频，不用再每个月花钱买各种VIP，只需要简单的安装一个脚本，直接跳过广告，播放VIP最新电视剧。让我们一起愉快的追剧~<a id="more"></a></p><h3 id="2、准备"><a href="#2、准备" class="headerlink" title="2、准备"></a>2、准备</h3><ul><li>Firefly 萤火虫<blockquote><p>由于下载谷歌浏览器和安装Tampermonkey插件都需要翻墙才能够完成，在这里给大家分享一个翻墙的软件萤火虫，简单方便，关键是还免费，在Github上开源的，可以<a href="https://github.com/yinghuocho/firefly-proxy" target="_blank" rel="noopener">下载单文件版本</a>，下载后双击运行即可。</p></blockquote></li></ul><img src="/2018/03/11/破解VIP会员视频/1.png" title="This is an example image 1"><ul><li><p>谷歌浏览器</p><blockquote><p>运行萤火虫软件后，在<a href="https://www.google.cn/chrome/" target="_blank" rel="noopener">官网下载</a>一个谷歌浏览器，因为谷歌浏览器的插件比较丰富，个人比较喜欢，就以chrome为例子，Safari，火狐Firefox，UC浏览器等也是可以的。</p></blockquote></li><li><p>Tampermonkey插件</p><blockquote><p>接下来安装<a href="http://tampermonkey.net/?ext=dhdg&amp;browser=chrome" target="_blank" rel="noopener">Tampermonkey插件</a>（俗称油猴），安装稳定版（黑色图标）即可。</p></blockquote></li></ul><img src="/2018/03/11/破解VIP会员视频/2.png" title="This is an example image 2"><p>安装完成后会在谷歌浏览器的左上角有一个相应的图标</p><img src="/2018/03/11/破解VIP会员视频/3.png" title="This is an example image 3"><h3 id="3、安装破解VIP会员视频脚本"><a href="#3、安装破解VIP会员视频脚本" class="headerlink" title="3、安装破解VIP会员视频脚本"></a>3、安装破解VIP会员视频脚本</h3><p>a. 先进入获取脚本页面</p><img src="/2018/03/11/破解VIP会员视频/4.png" title="This is an example image 4"><p>b. 再进入<a href="https://greasyfork.org/zh-CN" target="_blank" rel="noopener">GreasyFork页面</a></p><img src="/2018/03/11/破解VIP会员视频/5.png" title="This is an example image 5"><p>c.    搜索关键词VIP</p><img src="/2018/03/11/破解VIP会员视频/6.png" title="This is an example image 6"><br><br><br><img src="/2018/03/11/破解VIP会员视频/7.png" title="This is an example image 7"><p>d.    安装此脚本</p><img src="/2018/03/11/破解VIP会员视频/8.png" title="This is an example image 8"><br><br><br><img src="/2018/03/11/破解VIP会员视频/9.png" title="This is an example image 9"><p>e．检查安装是否成功<br>在管理面板中，可以看到是否含有破解VIP会员视频集合脚本，若有则表示安装成功。</p><img src="/2018/03/11/破解VIP会员视频/10.png" title="This is an example image 10"><br><br><br><img src="/2018/03/11/破解VIP会员视频/11.png" title="This is an example image 11"><h3 id="4、追剧"><a href="#4、追剧" class="headerlink" title="4、追剧"></a>4、追剧</h3><p>在谷歌浏览器中打开爱奇艺官网，输入最近热播的电视剧《老男孩》，点击最新需要VIP才能看的12集，将鼠标放到左上角边上的播放按钮，选择百域阁，点击即可播放，无90秒烦人的广告，如截图。</p><img src="/2018/03/11/破解VIP会员视频/12.png" title="This is an example image 12"><br><br><br><img src="/2018/03/11/破解VIP会员视频/13.png" title="This is an example image 13"><p>如果百域阁解析播放不了，换一个猫云或其他的解析地址，多试试总是能看的。腾讯、优酷视频方法都是一样的，这个技能大家get起来吧~</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1、前言&quot;&gt;&lt;a href=&quot;#1、前言&quot; class=&quot;headerlink&quot; title=&quot;1、前言&quot;&gt;&lt;/a&gt;1、前言&lt;/h3&gt;&lt;p&gt;这次给追剧的同学带来一个福利，一键破解[优酷|腾讯|乐视|爱奇艺]等VIP或会员视频，不用再每个月花钱买各种VIP，只需要简单的安装一个脚本，直接跳过广告，播放VIP最新电视剧。让我们一起愉快的追剧~
    
    </summary>
    
    
    
      <category term="教程" scheme="http://seaworth.github.io/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>win10系统安装教程</title>
    <link href="http://seaworth.github.io/2018/03/04/win10%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"/>
    <id>http://seaworth.github.io/2018/03/04/win10系统安装教程/</id>
    <published>2018-03-04T13:15:14.000Z</published>
    <updated>2018-12-10T14:03:15.322Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、前言"><a href="#1、前言" class="headerlink" title="1、前言"></a>1、前言</h3><p>在这个信息爆炸的时代，几乎人人都有一台电脑，有时候电脑用久了很卡，或是出现莫名其妙的问题，你就会想到重新安装系统。每次重装系统都叫别人帮忙总显得麻烦，不如自己动手，丰衣足食。安装系统成为一种必备的技能。其实安装系统并没有想象的那么难，曾经的我也是一个小白，大一买来电脑生怕出问题，害怕把电脑装坏了。还好寝室有个电脑高手，看着他经常装系统，从Windows的xp到win10，ubuntu，最好玩了的是把联想笔记本装成了苹果系统，从此有了一台“黑苹果”，跟着室友我也会学会装系统了哈哈，只要不嫌麻烦，不断折腾，总会安装好的。在这里给大家分享一种安装系统的方法，用UltraISO（俗称软碟通）把Win10 ISO镜像写入U盘制作系统启动盘，再在bios界面设置U盘启动，然后一路回车，最后会遇见你的win10！<a id="more"></a></p><h3 id="2、准备"><a href="#2、准备" class="headerlink" title="2、准备"></a>2、准备</h3><ul><li><p>一个大于4G的U盘 </p><blockquote><p>注意提前备份好U盘上的文件，制作启动盘时会格式化里面的文件</p></blockquote></li><li><p>UltraISO（俗称软碟通）软件 </p><blockquote><p>百度下载一个即可</p></blockquote></li><li><p>Win10 ISO镜像 </p><blockquote><p>给大家推荐一个<a href="https://msdn.itellyou.cn/" target="_blank" rel="noopener">下载Windows系统的网址</a>，在百度上搜索win10系统下载，很多都不是微软原版的，并集成了很多常用软件或垃圾软件进去，MSDN网站里是正版纯净的Windows系统，MSDN是微软面向软件开发者所建的一个网站，它里面的资源很多，包括操作系统和Office软件。</p></blockquote></li></ul><p>注意下载操作系统前，先查看自己的电脑是32位还是64位，下载对应的操作系统，保证系统和电脑硬件匹配以发挥最好的性能，x86对应32位，x64对应64位。</p><img src="/2018/03/04/win10系统安装教程/1.png" title="This is an example image"><h3 id="3、制作启动盘"><a href="#3、制作启动盘" class="headerlink" title="3、制作启动盘"></a>3、制作启动盘</h3><p>打开UltraISO（俗称软碟通）软件，界面如下</p><img src="/2018/03/04/win10系统安装教程/2.png" title="This is an example image"><p>按照截图操作即可</p><ul><li>1.打开win10镜像文件ios<br><img src="/2018/03/04/win10系统安装教程/3.png" title="This is an example image"></li><li>2.选中要制作启动盘的U盘<br><img src="/2018/03/04/win10系统安装教程/4.png" title="This is an example image"></li><li>3.启动-&gt;写入硬盘映像<br><img src="/2018/03/04/win10系统安装教程/5.png" title="This is an example image"><br><br><img src="/2018/03/04/win10系统安装教程/6.png" title="This is an example image"></li></ul><p>刻录成功后，打开资源管理器，你的U盘会变成如下样式，代表着启动盘制作成功了。</p><img src="/2018/03/04/win10系统安装教程/7.png" title="This is an example image"><p>到这里已经成功了一半了。</p><h3 id="4、在bios下设置U盘启动"><a href="#4、在bios下设置U盘启动" class="headerlink" title="4、在bios下设置U盘启动"></a>4、在bios下设置U盘启动</h3><p>将制作好的U盘插入将要安装的电脑上，根据你电脑的品牌型号，在网上搜索怎样进入bios界面，设置U盘启动。我的电脑是台式惠普，开机时按住F9进入bios界面，选择启动盘SanDisk，回车进入安装界面。</p><img src="/2018/03/04/win10系统安装教程/8.png" title="This is an example image"><p>然后根据提示一路回车，你就会遇见你的win10！</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1、前言&quot;&gt;&lt;a href=&quot;#1、前言&quot; class=&quot;headerlink&quot; title=&quot;1、前言&quot;&gt;&lt;/a&gt;1、前言&lt;/h3&gt;&lt;p&gt;在这个信息爆炸的时代，几乎人人都有一台电脑，有时候电脑用久了很卡，或是出现莫名其妙的问题，你就会想到重新安装系统。每次重装系统都叫别人帮忙总显得麻烦，不如自己动手，丰衣足食。安装系统成为一种必备的技能。其实安装系统并没有想象的那么难，曾经的我也是一个小白，大一买来电脑生怕出问题，害怕把电脑装坏了。还好寝室有个电脑高手，看着他经常装系统，从Windows的xp到win10，ubuntu，最好玩了的是把联想笔记本装成了苹果系统，从此有了一台“黑苹果”，跟着室友我也会学会装系统了哈哈，只要不嫌麻烦，不断折腾，总会安装好的。在这里给大家分享一种安装系统的方法，用UltraISO（俗称软碟通）把Win10 ISO镜像写入U盘制作系统启动盘，再在bios界面设置U盘启动，然后一路回车，最后会遇见你的win10！
    
    </summary>
    
    
    
      <category term="win10安装" scheme="http://seaworth.github.io/tags/win10%E5%AE%89%E8%A3%85/"/>
    
      <category term="教程" scheme="http://seaworth.github.io/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Hexo+Github搭建yilia主题的博客</title>
    <link href="http://seaworth.github.io/2018/02/04/Hexo+Github%E6%90%AD%E5%BB%BAyilia%E4%B8%BB%E9%A2%98%E7%9A%84%E5%8D%9A%E5%AE%A2/"/>
    <id>http://seaworth.github.io/2018/02/04/Hexo+Github搭建yilia主题的博客/</id>
    <published>2018-02-04T06:45:01.000Z</published>
    <updated>2018-12-08T12:38:05.443Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h3><p>什么是Hexo？</p><blockquote><p><a href="https://hexo.io/zh-cn/docs/index.html" target="_blank" rel="noopener">Hexo</a> 是一个快速、简洁且高效的博客发布工具。Hexo支持Markdown格式，众多优秀插件和主题。在几秒内，即可利用靓丽的主题生成静态网页。<br><a id="more"></a></p></blockquote><p>什么是Github？</p><blockquote><p>Github是一个面向开源及私有软件项目的托管平台，因为只支持git 作为唯一的版本库格式进行托管，故名Github。</p></blockquote><p>什么是Git？</p><blockquote><p>Git是目前世界上最先进的分布式版本控制系统。</p></blockquote><h3 id="2-准备"><a href="#2-准备" class="headerlink" title="2 准备"></a>2 准备</h3><p>我是在win10环境下配置的，搭建博客需要以下的准备工作：</p><ul><li>Github账号<br>作用：是用来做博客的远程仓库，<a href="https://github.com/" target="_blank" rel="noopener">Github官网</a>申请一个账户，每一个Github账户（如我的账户名为Seaworth））对应有一个域名（则<a href="https://seaworth.github.io/">我的博客地址</a> <a href="https://seaworth.github.io/）。">https://seaworth.github.io/）。</a></li><li>Git软件安装<br>作用：把本地的hexo内容提交到github上去，<a href="https://git-scm.com/download/win" target="_blank" rel="noopener">Git软件官网下载</a>，安装即可。</li><li>Node.js安装<br>作用：用来创建hexo博客框架的，<a href="https://nodejs.org/en/" target="_blank" rel="noopener">Node.js官网下载</a>，安装即可。</li></ul><p>在Git Bash中验证上述软件是否安装成功，如果能够出现以下版本信息，则说明安装成功。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git version <span class="comment"># git的版本信息</span></span><br><span class="line">git version 2.8.1.windows.1</span><br><span class="line">$ node -v <span class="comment"># node的版本信息</span></span><br><span class="line">v8.9.4</span><br></pre></td></tr></table></figure></p><p>如果您的电脑上已经安装上述必备程序，那么恭喜您！接下来只需要使用 npm 即可完成 Hexo 的安装。</p><ul><li>Hexo安装<br>在Git Bash中输入以下命令安装 Hexo</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>检查是否安装成功，出现版本信息，安装成功。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ hexo -v</span><br><span class="line">hexo-cli: 1.0.4</span><br><span class="line">os: Windows_NT 10.0.16299 win32 x64</span><br><span class="line">http_parser: 2.7.0</span><br><span class="line">node: 8.9.4</span><br><span class="line">v8: 6.1.534.50</span><br><span class="line">uv: 1.15.0</span><br><span class="line">zlib: 1.2.11</span><br><span class="line">ares: 1.10.1-DEV</span><br><span class="line">modules: 57</span><br><span class="line">nghttp2: 1.25.0</span><br><span class="line">openssl: 1.0.2n</span><br><span class="line">icu: 59.1</span><br><span class="line">unicode: 9.0</span><br><span class="line">cldr: 31.0.1</span><br><span class="line">tz: 2017b</span><br></pre></td></tr></table></figure></p><h3 id="3-建站"><a href="#3-建站" class="headerlink" title="3 建站"></a>3 建站</h3><p>安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。我是在F磁盘新建文件夹hexo，这个hexo文件夹中将存放整个博客的文章和网站的配置文件等，可根据自己的需要更改。<br>在hexo文件夹下右键打开Git Bash命令行<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init  <span class="comment">#将blog初始化</span></span><br></pre></td></tr></table></figure></p><p>hexo会自动下载一些文件到这个目录，包括node_modules，目录结构如下图：<br><img src="/2018/02/04/Hexo+Github搭建yilia主题的博客/QQ截图20180203150040.png" title="This is an example image"><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo g  <span class="comment"># 也可以写成hexo generate，生成静态文件</span></span><br><span class="line">$ hexo s  <span class="comment"># 也可以写成hexo server，启动服务器</span></span><br></pre></td></tr></table></figure></p><p>执行以上命令之后，hexo文件夹中会增加两个文件，其中一个public文件夹生成相关html文件：<br><img src="/2018/02/04/Hexo+Github搭建yilia主题的博客/QQ截图20180202153116.png" title="This is an example image"><br><img src="/2018/02/04/Hexo+Github搭建yilia主题的博客/QQ截图20180203151320.png" title="This is an example image"><br><img src="/2018/02/04/Hexo+Github搭建yilia主题的博客/QQ截图20180203150931.png" title="This is an example image"></p><p>hexo s是开启本地预览服务，打开浏览器访问 <a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a> 即可看到如下页面：<br><img src="/2018/02/04/Hexo+Github搭建yilia主题的博客/QQ截图20180203151852.png" title="This is an example image"></p><p>第一次初始化的时候hexo已经帮我们写了一篇名为 Hello World 的文章，这是默认的主题landscape。</p><h3 id="4-配置yilia主题"><a href="#4-配置yilia主题" class="headerlink" title="4 配置yilia主题"></a>4 配置yilia主题</h3><p>默认主题不是很好看，我们就来换个好看点的主题，这里是<a href="https://hexo.io/themes/" target="_blank" rel="noopener">官方主题</a><br>我比较喜欢的两个主题是<a href="https://github.com/litten/hexo-theme-yilia" target="_blank" rel="noopener">hexo-theme-yilia</a>和<a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">hexo-theme-next</a>，我选择的yilia主题，比较喜欢他的风格，崇尚简约优雅。<br>在hexo文件夹下右键打开Git Bash命令行<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/litten/hexo-theme-yilia.git themes/yilia</span><br></pre></td></tr></table></figure></p><p>下载后，themes文件夹下会多一个yilia文件夹<br><img src="/2018/02/04/Hexo+Github搭建yilia主题的博客/QQ截图20180203154359.png" title="This is an example image"></p><p>然后，在<a href="https://github.com/litten/BlogBackup/blob/master/_config.yml" target="_blank" rel="noopener">yilia主题的博客备份</a>中的_config.yml配置文件中，复制里面的全部内容，粘贴到在hexo文件夹下的_config.yml文件。<br>在hexo文件夹下右键打开Git Bash命令行<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo g</span><br><span class="line">$ hexo s</span><br></pre></td></tr></table></figure></p><p>打开浏览器访问 <a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a> ，即可看到更改为yilia主题的页面<br><img src="/2018/02/04/Hexo+Github搭建yilia主题的博客/QQ截图20180203161438.png" title="This is an example image"></p><p>此时就只需要更改hexo文件夹下的_config.yml配置文件和yilia文件夹下的_config.yml配置文件，yilia主题的作者<a href="http://litten.me/" target="_blank" rel="noopener">Litten</a>将配置文件的备注写的比较清楚，不过作为小白的我还是改了一些时间，也遇到一些问题，分享给大家，避免的大家也在类似的地方卡住。<br>hexo文件夹下的_config.yml配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># URL</span></span><br><span class="line"><span class="comment">## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'</span></span><br><span class="line">url: http://seaworth.github.io/  <span class="comment"># 这里是自己博客的地址，但要以http开头，不是https</span></span><br><span class="line">root: /</span><br><span class="line">permalink: :year/:month/:day/:title/</span><br></pre></td></tr></table></figure><p>yilia文件夹下的_config.yml配置文件<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 支付宝二维码图片地址，跟你设置头像的方式一样。比如：/assets/img/alipay.jpg</span></span><br><span class="line">alipay: <span class="string">"/img/alipay.jpg"</span></span><br></pre></td></tr></table></figure></p><p>更改支付宝赞赏的图片的时候，是以yilia文件下的source文件为根目录，所以将alipay.jpg图片放到source/img/目录下后，在对应位置输入”/img/alipay.jpg”即可，注意alipay: 冒号后面有空格。</p><h3 id="5-发布到Github"><a href="#5-发布到Github" class="headerlink" title="5 发布到Github"></a>5 发布到Github</h3><p>此时还只能够在本地的浏览器看自己的博客，当我们把本地的hexo博客网页配置和博客文章推送到Github上，生成静态网页，所有人都可以访问博客了。</p><h4 id="5-1-创建repository"><a href="#5-1-创建repository" class="headerlink" title="5.1 创建repository"></a>5.1 创建repository</h4><p>repository相当于一个仓库，用来放置代码文件。首先，登陆进入<a href="https://github.com/" target="_blank" rel="noopener">Github</a>，并进入个人页面，然后New一个repository<br><img src="/2018/02/04/Hexo+Github搭建yilia主题的博客/QQ截图20180203164834.png" title="This is an example image"></p><p>创建时，只需要填写Repository name即可，当然这个名字的格式必须为yourname.github.io，例如我的为<a href="https://github.com/Seaworth/Seaworth.github.io" target="_blank" rel="noopener">Seaworth.github.io</a><br>然后编辑F:/hexo下的_config.yml文件，建议使用Notepad++编辑器。将deploy部分修改成自己的信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  <span class="built_in">type</span>: git</span><br><span class="line">  repo: git@github.com:Seaworth/Seaworth.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p>repo后面填写以下红色方框中的内容<br><img src="/2018/02/04/Hexo+Github搭建yilia主题的博客/QQ截图20180203170735.png" title="This is an example image"></p><h4 id="5-2-配置SSH-keys"><a href="#5-2-配置SSH-keys" class="headerlink" title="5.2 配置SSH keys"></a>5.2 配置SSH keys</h4><p>为什么要配置这个呢？因为你提交代码肯定要拥有你的Github权限才可以，但是直接使用用户名和密码太不安全了，所以我们使用ssh key来解决本地和服务器的连接问题。<br>在Git Bash中执行如下命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ~/. ssh <span class="comment">#检查本机已存在的ssh密钥</span></span><br></pre></td></tr></table></figure></p><p>如果提示：No such file or directory 说明你是第一次使用git。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">"你的邮件地址"</span></span><br></pre></td></tr></table></figure><p>然后连续3次回车，最终会在C:\Users\Administrator.ssh\目录下生成三个文件，找到id_rsa.pub文件，记事本打开并复制里面的内容<br><img src="/2018/02/04/Hexo+Github搭建yilia主题的博客/QQ截图20180203172124.png" title="This is an example image"></p><p>打开你的github主页，点击头像-&gt;Settings-&gt; SSH and GPG keys -&gt; New SSH key：<br><img src="/2018/02/04/Hexo+Github搭建yilia主题的博客/QQ截图20180203172738.png" title="This is an example image"></p><p>将刚复制的内容粘贴到key那里，title随便填。<br>测试一下SSH是否配置成功，输入以下命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -T git@github.com</span><br></pre></td></tr></table></figure></p><p>你可能会看到有警告，输入“yes”就好，然后会看到</p><blockquote><p>Hi Seaworth! You’ve successfully authenticated, but GitHub does not provide shell access.</p></blockquote><p>有这个信息说明SSH已配置成功！</p><h4 id="5-3-发布"><a href="#5-3-发布" class="headerlink" title="5.3 发布"></a>5.3 发布</h4><p>执行以下命令发布到到Github上。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo g </span><br><span class="line">$ hexo d</span><br></pre></td></tr></table></figure><p>如果执行hexo d命令报错，就先安装一下hexo-deployer-git这个模块：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></p><p>安装好了继续执行hexo d部署命令，输入gitHub的账号密码，就可以访问了。</p><h3 id="6-使用hexo写博客"><a href="#6-使用hexo写博客" class="headerlink" title="6 使用hexo写博客"></a>6 使用hexo写博客</h3><p>Hexo使用Markdown解析文章，我是使用的<a href="http://soft.xiaoshujiang.com/" target="_blank" rel="noopener">小书匠</a>在线编辑器+印象笔记，编写的文章直接同步到印象笔记挺方便的。<br>hexo常用的命令，#后面为注释。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ hexo n <span class="comment">#完整命令为hexo new,用于新建一篇文章</span></span><br><span class="line">$ hexo g <span class="comment">#完整命令为hexo generate,用于生成静态文件</span></span><br><span class="line">$ hexo s <span class="comment">#完整命令为hexo server,用于启动服务器，主要用来本地预览</span></span><br><span class="line">$ hexo d <span class="comment">#完整命令为hexo deploy,用于将本地文件发布到github上</span></span><br></pre></td></tr></table></figure></p><p>定位到我们的hexo根目录，执行命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo n <span class="string">"hello my first blog"</span> <span class="comment"># 新建一篇文章名为hello my first blog</span></span><br><span class="line">INFO  Created: F:\blog\<span class="built_in">source</span>\_posts\hello-my-first-blog.md</span><br></pre></td></tr></table></figure></p><p>Hexo会帮我们在F:\blog\source_posts下生成相关md文件，打开这个文件就可以开始写博客了，Markdown语法编写，默认生成如下内容：<br><img src="/2018/02/04/Hexo+Github搭建yilia主题的博客/QQ截图20180203175708.png" title="This is an example image"></p><p>在后面添加##我的第一篇博客，啦啦啦！，写完文章后，在hexo文件夹下打开Git Bash输入<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo g</span><br><span class="line">$ hexo d</span><br></pre></td></tr></table></figure></p><p>然后使用 <a href="https://yourname.github.io" target="_blank" rel="noopener">https://yourname.github.io</a> 进行访问。<br><img src="/2018/02/04/Hexo+Github搭建yilia主题的博客/QQ截图20180203180907.png" title="This is an example image"></p><p>到这里就差不多搭建好了一个属于自己的博客了，还有一些细节的东西（如访问统计）可以后面慢慢完善，后面就只是发布文章了，这是我第一次写博客，有些地方可能说的不是很全面，搭建的过程中难免会遇到一些问题，在百度上搜索大部分都能够解决，只要怀着一颗折腾到底的心，相信一定能够搭建好属于自己的个人博客的！</p><h3 id="7-参考"><a href="#7-参考" class="headerlink" title="7 参考"></a>7 参考</h3><p><a href="http://blog.haoji.me/build-blog-website-by-hexo-github.html?from=xa" target="_blank" rel="noopener">使用hexo+github搭建免费个人博客详细教程</a><br><a href="http://tengj.top/2016/02/22/hexo1/" target="_blank" rel="noopener">hexo干货系列：（一）hexo+gitHub搭建个人独立博客</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1 概述&quot;&gt;&lt;/a&gt;1 概述&lt;/h3&gt;&lt;p&gt;什么是Hexo？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://hexo.io/zh-cn/docs/index.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt; 是一个快速、简洁且高效的博客发布工具。Hexo支持Markdown格式，众多优秀插件和主题。在几秒内，即可利用靓丽的主题生成静态网页。&lt;br&gt;
    
    </summary>
    
    
    
      <category term="hexo" scheme="http://seaworth.github.io/tags/hexo/"/>
    
      <category term="yilia" scheme="http://seaworth.github.io/tags/yilia/"/>
    
  </entry>
  
  <entry>
    <title>Hello Seaworth的第一篇博客</title>
    <link href="http://seaworth.github.io/2018/01/26/hello%20Seaworth%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
    <id>http://seaworth.github.io/2018/01/26/hello Seaworth的第一篇博客/</id>
    <published>2018-01-26T10:36:00.000Z</published>
    <updated>2018-01-27T14:39:09.395Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-初识博客"><a href="#1-初识博客" class="headerlink" title="1 初识博客"></a>1 初识博客</h2><p>作为一个码农怎么能没有一个博客呢？最近在学习Python这门语言，在网上发现了<a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000" target="_blank" rel="noopener">廖雪峰的官方网站</a>上的Python教程讲得挺好，通俗易懂，知识点比较全，每一小节后面还有习题。在学习的过程中，遇到一些问题通过百度，在许多大牛的技术博客上寻找到了解决方法。心里想到自己也要拥有一个博客，于是自己就开始尝试着搭建个人博客。本来开始也想过直接就在CSDN、Wordpress、博客园、简书上面创建自己的博客，但偶然间发现Github上也可以搭建博客，就果断选择了Github+Hexo+yilia。<a id="more"></a>主要有以下几点原因：</p><ul><li>希望能够熟悉Github和Git的使用</li><li>觉得<a href="http://litten.me/" target="_blank" rel="noopener">yilia</a>主题的风格很简洁，漂亮</li></ul><h2 id="2-做点什么"><a href="#2-做点什么" class="headerlink" title="2 做点什么"></a>2 做点什么</h2><p>于是自己就开始捣腾起来，经过三天断断续续的折腾，终于搭好了我的个人博客，就像拥有了属于自己的小世界，内心还是有点小激动。以后开始给我的博客添砖加瓦，并且坚持更新。以后要向码农的方向不但进化了，博客的内容要是以下几方面：</p><ul><li>分享一些比较实用的资源工具</li><li>分享一些在学习过程中的总结和经验</li><li>偶尔装装文艺青年，读书，写写随笔</li></ul><h2 id="3-心得感想"><a href="#3-心得感想" class="headerlink" title="3 心得感想"></a>3 心得感想</h2><p>不知道从什么时候开始，发现自己渐渐地向码农之路越走越近。希望自己成为一个不只是会写代码的程序猿，除了撸代码之外，还多读书，多运动，多分享。<br>规划好自己的旅程，坚持自己的目标，不断前行。</p><blockquote><p>青山不改，绿水长流<br>希望能遇见那个未知的自己！</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-初识博客&quot;&gt;&lt;a href=&quot;#1-初识博客&quot; class=&quot;headerlink&quot; title=&quot;1 初识博客&quot;&gt;&lt;/a&gt;1 初识博客&lt;/h2&gt;&lt;p&gt;作为一个码农怎么能没有一个博客呢？最近在学习Python这门语言，在网上发现了&lt;a href=&quot;https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;廖雪峰的官方网站&lt;/a&gt;上的Python教程讲得挺好，通俗易懂，知识点比较全，每一小节后面还有习题。在学习的过程中，遇到一些问题通过百度，在许多大牛的技术博客上寻找到了解决方法。心里想到自己也要拥有一个博客，于是自己就开始尝试着搭建个人博客。本来开始也想过直接就在CSDN、Wordpress、博客园、简书上面创建自己的博客，但偶然间发现Github上也可以搭建博客，就果断选择了Github+Hexo+yilia。
    
    </summary>
    
    
    
      <category term="随笔" scheme="http://seaworth.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
</feed>
